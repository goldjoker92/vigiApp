#!/bin/sh
# Husky shim (peut activer `set -e` en interne)
. "$(dirname "$0")/_/husky.sh" 2>/dev/null || true

# D√©sactive l‚Äôarr√™t sur erreur pour ce hook
set +e

echo ""
echo "üîé [husky] V√©rification (non-bloquante) des d√©pendances Expo/Yarn..."

# 1) Check alignement Expo (info only)
CI=1 yarn expo install --check >/dev/null 2>&1 || \
  echo "‚ÑπÔ∏è expo install --check a renvoy√© un code ‚â† 0 (ignor√©)"

# 2) Dedupe (selon Yarn major)
YARN_VERSION=$(yarn -v 2>/dev/null) || YARN_VERSION=""
YARN_MAJOR=$(echo "$YARN_VERSION" | cut -d. -f1 2>/dev/null)

if [ -n "$YARN_MAJOR" ] && [ "$YARN_MAJOR" -ge 2 ] 2>/dev/null; then
  yarn dedupe >/dev/null 2>&1 \
    && echo "üßπ yarn dedupe (Berry) OK" \
    || echo "‚ÑπÔ∏è Tips Berry: yarn dedupe && yarn install"
else
  npx --yes yarn-deduplicate yarn.lock >/dev/null 2>&1 \
    && echo "üßπ yarn-deduplicate (v1) OK" \
    || echo "‚ÑπÔ∏è Tips v1: npm i -D yarn-deduplicate && npx yarn-deduplicate yarn.lock && yarn install"
fi

# 3) D√©termination des fichiers modifi√©s du push
echo "üõ†Ô∏è  ESLint + Prettier (non-bloquant) sur les fichiers modifi√©s‚Ä¶"

CHANGED_FILES=""

# Si rien n'arrive sur stdin (cas GUI/PowerShell), on fait un fallback
if [ -t 0 ]; then
  # Pas de stdin -> fallback upstream...HEAD, sinon dernier commit
  upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
  if [ -n "$upstream" ]; then
    CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRTUXB "$upstream"...HEAD 2>/dev/null)
  else
    CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRTUXB HEAD~1 HEAD 2>/dev/null)
  fi
else
  # Lecture des refs envoy√©es par Git
  while read -r local_ref local_sha remote_ref remote_sha; do
    if [ -z "$remote_sha" ] || [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
      RANGE="${local_sha}~1 ${local_sha}"
    else
      RANGE="${remote_sha} ${local_sha}"
    fi
    files=$(git diff --name-only --diff-filter=ACMRTUXB $RANGE 2>/dev/null)
    [ -n "$files" ] && CHANGED_FILES="$CHANGED_FILES
$files"
  done || true
fi

# Filtre extensions g√©r√©es + fichiers formatables
echo "$CHANGED_FILES" | while read -r f; do
  case "$f" in
    *.js|*.jsx|*.ts|*.tsx|*.json|*.md|*.css|*.scss) [ -f "$f" ] && echo "$f";;
  esac
done | sort -u > /tmp/changed_files.txt 2>/dev/null

# 4) ESLint --fix (non-bloquant)
if [ -s /tmp/changed_files.txt ] && command -v npx >/dev/null 2>&1; then
  echo "üîß ESLint --fix‚Ä¶"
  xargs -a /tmp/changed_files.txt -r npx eslint --fix >/dev/null 2>&1 || \
    echo "‚ÑπÔ∏è ESLint a retourn√© un code ‚â† 0 (ignor√©)"
  # 5) Prettier --write (non-bloquant)
  echo "üé® Prettier --write‚Ä¶"
  xargs -a /tmp/changed_files.txt -r npx prettier --write >/dev/null 2>&1 || \
    echo "‚ÑπÔ∏è Prettier a retourn√© un code ‚â† 0 (ignor√©)"
else
  echo "‚ÑπÔ∏è Aucun fichier modifi√© pertinent, ou npx indisponible. Skip ESLint/Prettier."
fi

echo "‚úÖ [husky] Non-bloquant. Push autoris√©."
exit 0
