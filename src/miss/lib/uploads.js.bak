/* ============================================================================
   src/miss/lib/uploads.js
   Upload multipart vers Cloud Functions, avec:
   - Backoff + idempotency
   - Fallback multi-endpoints (renommage CF, alias, etc.)
   - Logs détaillés (URL, status, extrait réponse)
   - Pas de Content-Type forcé (FormData gère le boundary)
   ============================================================================ */

import { Platform, Image } from 'react-native';
import { onlyDigits } from './helpers';

// ---------------------------------------------------------------------------
// CONFIG — ajoute ici toutes tes bases (si tu as plusieurs régions/projets)
const CF_UPLOAD_BASES = [
  'https://southamerica-east1-vigiapp-c7108.cloudfunctions.net',
  // 'https://us-central1-<autre-projet>.cloudfunctions.net',
];

// Pour chaque kind, on définit plusieurs chemins de CF (ordre = priorité)
const CF_UPLOAD_PATHS = {
  photo: ['mcUpload', 'uploadChildPhoto', 'uploadPhoto'],
  id: ['mcUpload', 'uploadIdDocument', 'uploadId'],
  linkDoc: ['mcUpload', 'uploadLinkDocument', 'uploadLink'],
};

// Taille max (15MB)
const MAX_FILE_SIZE = 15 * 1024 * 1024;

// ---------------------------------------------------------------------------
// Utils
async function getImageDimensions(uri) {
  if (!uri) {return null;}
  return new Promise((resolve) => {
    Image.getSize(
      uri,
      (w, h) => resolve({ width: w, height: h }),
      () => resolve(null),
    );
  });
}

function guessDocKind({ mime = '', name = '', dims = null }) {
  const reasons = [];
  const ext =
    String(name || '')
      .split('.')
      .pop()
      ?.toLowerCase() || '';
  if (mime) {reasons.push(`mime:${mime}`);}
  if (ext) {reasons.push(`ext:${ext}`);}

  if (dims && dims.width && dims.height) {
    const ratio = dims.width / dims.height;
    reasons.push(`ratio:${ratio.toFixed(2)}`);
    if (ratio >= 1.35 && ratio <= 1.85 && dims.width >= 400)
      {return { kind: 'id_card_like', confidence: 0.8, reasons };}
    if (ratio < 0.9) {return { kind: 'portrait_photo', confidence: 0.75, reasons };}
    if (ratio >= 1.9) {return { kind: 'landscape_scan_or_photo', confidence: 0.6, reasons };}
    return { kind: 'document_like', confidence: 0.55, reasons };
  }
  if (ext === 'pdf' || mime === 'application/pdf')
    {return { kind: 'pdf_document', confidence: 0.9, reasons };}
  return { kind: 'unknown', confidence: 0.3, reasons };
}

export function makeIdempotencyKey({ caseId, userId, name, size }) {
  const base = `${caseId || 'X'}:${userId || 'anon'}:${name || 'file'}:${size || '0'}:${Date.now()}`;
  let h = 0;
  for (let i = 0; i < base.length; i++) {
    h = (h << 5) - h + base.charCodeAt(i);
    h |= 0;
  }
  return `mc_${Math.abs(h)}`;
}
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const isMimeAllowed = (m) => m?.startsWith('image/') || m === 'application/pdf';
const isExtAllowed = (n) =>
  ['jpg', 'jpeg', 'png', 'pdf', 'heic', 'webp'].includes(
    String(n || '')
      .split('.')
      .pop()
      ?.toLowerCase(),
  );

function buildUploadCandidates(kind) {
  const paths = CF_UPLOAD_PATHS[kind] || [];
  const urls = [];
  for (const base of CF_UPLOAD_BASES) {for (const p of paths) {urls.push(`${base}/${p}`);}}
  return [...new Set(urls)];
}

// ---------------------------------------------------------------------------
// Upload principal (multipart) avec fallback
export async function uploadDocMultipart(options = {}) {
  const { uri, name, mime, size, caseId, kind, userId, cpfRaw, idempotencyKey, geo } = options;

  console.log('[MISSING_CHILD][UPLOAD] start', {
    uri: !!uri,
    name,
    mime,
    size,
    caseId,
    kind,
    userId,
  });
  if (!uri || !caseId || !kind)
    {return { ok: false, reason: 'Parâmetros insuficientes (uri/caseId/kind).' };}
  if (size && size > MAX_FILE_SIZE)
    {return { ok: false, reason: 'Arquivo muito grande (limite ~15MB).' };}
  if (mime && !isMimeAllowed(mime)) {return { ok: false, reason: 'Formato não suportado (mime).' };}
  if (name && !isExtAllowed(name))
    {return { ok: false, reason: 'Extensão de arquivo não suportada.' };}

  let dims = null;
  try {
    if (mime?.startsWith('image/')) {dims = await getImageDimensions(uri);}
  } catch {}
  const guessed = guessDocKind({ mime, name, dims });
  const idem = idempotencyKey || makeIdempotencyKey({ caseId, userId, name, size });

  const form = new FormData();
  form.append('caseId', String(caseId));
  form.append('kind', String(kind)); // "photo" | "id" | "linkDoc"
  form.append('userId', String(userId || ''));
  form.append('cpfDigits', cpfRaw ? onlyDigits(cpfRaw) : '');
  form.append(
    'client',
    JSON.stringify({ platform: Platform.OS, version: Platform.Version, dims, guessed }),
  );
  if (geo && typeof geo.lat === 'number' && typeof geo.lng === 'number')
    {form.append('geo', JSON.stringify({ lat: geo.lat, lng: geo.lng }));}
  form.append('file', {
    uri,
    name: name || `upload_${Date.now()}`,
    type: mime || 'application/octet-stream',
  });

  const candidates = buildUploadCandidates(kind);
  const backoff = [0, 700, 1600]; // 3 essais/URL

  for (const url of candidates) {
    for (let t = 0; t < backoff.length; t++) {
      if (backoff[t] > 0) {await sleep(backoff[t]);}
      try {
        const res = await fetch(url, {
          method: 'POST',
          body: form,
          headers: { Accept: 'application/json', 'X-Idempotency-Key': idem },
        });
        if (!res.ok) {
          let txt = '';
          try {
            txt = (await res.text()).slice(0, 200);
          } catch {}
          console.warn('[MISSING_CHILD][UPLOAD] http error', res.status, { url, txt });

          if (res.status === 404) {break;} // passe à l’URL suivante
          if (res.status === 409)
            {return { ok: false, reason: 'Requisição duplicada (idempotência).' };}
          if (res.status >= 400 && res.status < 500) {break;} // autre 4xx -> URL suivante
          continue; // 5xx -> retry même URL
        }

        let json = null;
        try {
          json = await res.json();
        } catch {}
        if (!json || !json.ok) {
          console.warn('[MISSING_CHILD][UPLOAD] bad json', { url, json });
          continue;
        }

        console.log('[MISSING_CHILD][UPLOAD] ok', {
          url,
          storedAt: json?.storedAt,
          redactedPath: json?.redactedPath,
        });
        return {
          ok: true,
          redactedUrl: json.redactedUrl,
          meta: {
            originalPath: json.originalPath,
            redactedPath: json.redactedPath,
            mimeServer: json.mime,
            extServer: json.ext,
            storedAt: json.storedAt,
            guessed,
          },
        };
      } catch (e) {
        console.warn('[MISSING_CHILD][UPLOAD] exception', e?.message || e, { url });
        continue; // réseau -> retry même URL
      }
    }
    console.warn('[MISSING_CHILD][UPLOAD] trying next candidate', { next: true });
  }

  return { ok: false, reason: 'Falha no upload (endpoint indisponível / 404).' };
}

// ---------------------------------------------------------------------------
// Wrappers front
export const uploadIdDocument = (p) => uploadDocMultipart({ ...p, kind: 'id' });
export const uploadLinkDocument = (p) => uploadDocMultipart({ ...p, kind: 'linkDoc' });
export const uploadChildPhoto = (p) => uploadDocMultipart({ ...p, kind: 'photo' });
