{
  "sourceFile": "app/grupo-sinalizar.jsx",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1758951742002,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1758951742002,
      "name": "Commit-0",
      "content": "// app/grupo-sinalizar.jsx\n// -------------------------------------------------------------\n// Flux \"Sinalizar\" blindé (JSX):\n// - Permissions + GPS (retry court)\n// - Reverse geocode Google-first + normalisation CEP/UF\n// - Résolution du groupId (route → user → Firestore)\n// - Décision: groupe/public + watchdog + toasts\n// - Signals (NetInfo / Expo Network / Expo Device) avec logs\n// -------------------------------------------------------------\n\nimport NetInfo from '@react-native-community/netinfo';\nimport * as Device from 'expo-device';\nimport * as Location from 'expo-location';\nimport * as Network from 'expo-network';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  Alert,\n  Animated,\n  Dimensions,\n  Easing,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\nimport { useAuthGuard } from '../hooks/useAuthGuard';\nimport CustomTopToast from './components/CustomTopToast';\n\n// CEP utils (Google-first avec cascades internes)\nimport { GOOGLE_MAPS_KEY, hasGoogleKey, resolveExactCepFromCoords } from '../utils/cep';\n\n// Firestore\nimport { collection, getDocs, limit, query, where } from 'firebase/firestore';\nimport { db } from '../firebase';\n\n// --- OPTION: selon ton schéma groupe ---\nconst GROUPS_USE_ARRAY_OF_CEPS = true; // true si { ceps: string[] }, false si { cep: string }\nconst ONLY_ACTIVE_GROUPS = true;\n\n/* ---------------- Loader téléphone ↔ satellite ---------------- */\nconst PhoneSatelliteLoader = memo(function PhoneSatelliteLoader() {\n  const pulse = useRef(new Animated.Value(0)).current;\n  const orbit = useRef(new Animated.Value(0)).current;\n\n  useEffect(() => {\n    Animated.loop(\n      Animated.sequence([\n        Animated.timing(pulse, {\n          toValue: 1,\n          duration: 1000,\n          easing: Easing.out(Easing.quad),\n          useNativeDriver: true,\n        }),\n        Animated.timing(pulse, {\n          toValue: 0,\n          duration: 1000,\n          easing: Easing.in(Easing.quad),\n          useNativeDriver: true,\n        }),\n      ]),\n    ).start();\n\n    Animated.loop(\n      Animated.timing(orbit, {\n        toValue: 1,\n        duration: 2600,\n        easing: Easing.linear,\n        useNativeDriver: true,\n      }),\n    ).start();\n  }, [pulse, orbit]);\n\n  const { width } = Dimensions.get('window');\n  const isSmall = width < 360;\n\n  const orbitRotate = orbit.interpolate({ inputRange: [0, 1], outputRange: ['0deg', '360deg'] });\n  const pulseScale = pulse.interpolate({ inputRange: [0, 1], outputRange: [0.8, 1.15] });\n  const ringOpacity = pulse.interpolate({ inputRange: [0, 1], outputRange: [0.35, 0.05] });\n\n  return (\n    <View style={styles.loaderWrap}>\n      <Animated.View style={[styles.satOrbit, { transform: [{ rotate: orbitRotate }] }]}>\n        <View style={styles.satBody}>\n          <View style={styles.satPanel} />\n          <View style={[styles.satPanel, { right: -14 }]} />\n        </View>\n      </Animated.View>\n\n      <Animated.View style={[styles.phone, { transform: [{ scale: pulseScale }] }]}>\n        <View style={styles.phoneScreen} />\n      </Animated.View>\n\n      <Animated.View\n        style={[styles.wave, { opacity: ringOpacity, transform: [{ scale: pulseScale }] }]}\n      />\n      <Animated.View\n        style={[\n          styles.wave,\n          { opacity: ringOpacity, transform: [{ scale: Animated.add(0.6, pulse) }] },\n        ]}\n      />\n\n      <Text style={[styles.loaderText, isSmall && { fontSize: 14 }]}>Detectando localização…</Text>\n    </View>\n  );\n});\n\n/* ----------------------- Helpers ---------------------- */\nfunction normalizeCep(v) {\n  if (!v) {\n    return null;\n  }\n  const clean = String(v).replace(/\\D/g, '');\n  return clean.length === 8 ? clean : null;\n}\nfunction isGenericCep(cep8) {\n  return !!cep8 && cep8.length === 8 && cep8.slice(5) === '000';\n}\nfunction toUF(s) {\n  const up = String(s || '')\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toUpperCase()\n    .trim();\n  const map = {\n    AC: 'AC',\n    AL: 'AL',\n    AP: 'AP',\n    AM: 'AM',\n    BA: 'BA',\n    CE: 'CE',\n    DF: 'DF',\n    ES: 'ES',\n    GO: 'GO',\n    MA: 'MA',\n    MT: 'MT',\n    MS: 'MS',\n    MG: 'MG',\n    PA: 'PA',\n    PB: 'PB',\n    PR: 'PR',\n    PE: 'PE',\n    PI: 'PI',\n    RJ: 'RJ',\n    RN: 'RN',\n    RS: 'RS',\n    RO: 'RO',\n    RR: 'RR',\n    SC: 'SC',\n    SP: 'SP',\n    SE: 'SE',\n    TO: 'TO',\n    ACRE: 'AC',\n    ALAGOAS: 'AL',\n    AMAPA: 'AP',\n    AMAPÁ: 'AP',\n    AMAZONAS: 'AM',\n    BAHIA: 'BA',\n    CEARA: 'CE',\n    CEARÁ: 'CE',\n    'DISTRITO FEDERAL': 'DF',\n    'ESPIRITO SANTO': 'ES',\n    'ESPÍRITO SANTO': 'ES',\n    GOIAS: 'GO',\n    GOIÁS: 'GO',\n    MARANHAO: 'MA',\n    MARANHÃO: 'MA',\n    'MATO GROSSO': 'MT',\n    'MATO GROSSO DO SUL': 'MS',\n    'MINAS GERAIS': 'MG',\n    PARA: 'PA',\n    PARÁ: 'PA',\n    PARAIBA: 'PB',\n    PARAÍBA: 'PB',\n    PARANA: 'PR',\n    PARANÁ: 'PR',\n    PERNAMBUCO: 'PE',\n    PIAUI: 'PI',\n    PIAUÍ: 'PI',\n    'RIO DE JANEIRO': 'RJ',\n    'RIO GRANDE DO NORTE': 'RN',\n    'RIO GRANDE DO SUL': 'RS',\n    RONDONIA: 'RO',\n    RONDÔNIA: 'RO',\n    RORAIMA: 'RR',\n    'SANTA CATARINA': 'SC',\n    'SAO PAULO': 'SP',\n    'SÃO PAULO': 'SP',\n    SERGIPE: 'SE',\n    TOCANTINS: 'TO',\n  };\n  return map[up] || (/^[A-Z]{2}$/.test(up) ? up : '');\n}\nfunction normalizeTxt(s) {\n  return String(s || '')\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ')\n    .toLowerCase()\n    .trim();\n}\nfunction sameZone(currentCep8, userCep8, addrCidade, addrUF, userCidade, userUF) {\n  if (currentCep8 && userCep8 && currentCep8 === userCep8) {\n    console.log('[SINALIZAR] sameZone = true (CEP strict)');\n    return true;\n  }\n  const villeOk =\n    !!addrCidade && !!userCidade && normalizeTxt(addrCidade) === normalizeTxt(userCidade);\n  const ufOk = !!addrUF && !!userUF && toUF(addrUF) === toUF(userUF);\n  const cepAmbigu =\n    !currentCep8 || !userCep8 || isGenericCep(currentCep8) || isGenericCep(userCep8);\n  console.log('[SINALIZAR] sameZone check:', {\n    villeOk,\n    ufOk,\n    cepAmbigu,\n    addrCidade,\n    userCidade,\n    addrUF,\n    userUF,\n    currentCep8,\n    userCep8,\n  });\n  return villeOk && ufOk && cepAmbigu;\n}\nfunction withTimeout(p, ms = 9000, tag = 'TIMEOUT') {\n  return new Promise((resolve, reject) => {\n    const t = setTimeout(() => reject(new Error(tag)), ms);\n    Promise.resolve(p)\n      .then((v) => {\n        clearTimeout(t);\n        resolve(v);\n      })\n      .catch((e) => {\n        clearTimeout(t);\n        reject(e);\n      });\n  });\n}\n\n// --- Firestore: lookups ---\nasync function lookupGroupByMembership(uid) {\n  if (!uid) {\n    return undefined;\n  }\n  console.log('[SINALIZAR][GROUP][FS] query', {\n    field: 'membersIds',\n    op: 'array-contains',\n    value: uid,\n  });\n  const q = query(collection(db, 'groups'), where('membersIds', 'array-contains', uid), limit(1));\n  const snap = await getDocs(q);\n  if (!snap.empty) {\n    const d0 = snap.docs[0];\n    console.log('[SINALIZAR][GROUP][FS] resolved membership:', d0.id, d0.data()?.name);\n    return d0.id;\n  }\n  return undefined;\n}\nasync function lookupGroupByCep(cep8) {\n  if (!cep8) {\n    return null;\n  }\n  const clauses = GROUPS_USE_ARRAY_OF_CEPS\n    ? [where('ceps', 'array-contains', cep8)]\n    : [where('cep', '==', cep8)];\n  if (ONLY_ACTIVE_GROUPS) {\n    clauses.push(where('isActive', '==', true));\n  }\n\n  console.log('[SINALIZAR][GROUP][FS] query', {\n    field: GROUPS_USE_ARRAY_OF_CEPS ? 'ceps' : 'cep',\n    op: GROUPS_USE_ARRAY_OF_CEPS ? 'array-contains' : '==',\n    value: cep8,\n  });\n\n  const q = query(collection(db, 'groups'), ...clauses, limit(1));\n  const snap = await getDocs(q);\n  if (snap.empty) {\n    return null;\n  }\n  const doc0 = snap.docs[0];\n  return { id: doc0.id, data: doc0.data() };\n}\n\n/* ----------------------- Signals intégrés ---------------------- */\nasync function safe(promise) {\n  try {\n    return await promise;\n  } catch {\n    return null;\n  }\n}\nasync function getWifiSnapshot() {\n  const ts = new Date().toISOString();\n  try {\n    const [net, ip, netState] = await Promise.all([\n      NetInfo.fetch(),\n      safe(Network.getIpAddressAsync()),\n      safe(Network.getNetworkStateAsync()),\n    ]);\n    const isWifi = net.type === 'wifi';\n    const ssid = net?.details?.ssid ?? null; // souvent null sur Android 10+\n    const snap = {\n      ssid,\n      isWifi,\n      strength: null,\n      frequency: null,\n      ipv4: ip ?? null,\n      dns: null,\n      ts,\n    };\n    if (!ssid && isWifi) {\n      snap.note = 'SSID indisponível (privacy Android/iOS)';\n    }\n    if (netState?.isInternetReachable === false) {\n      snap.note = 'Internet non joignable';\n    }\n    return snap;\n  } catch (e) {\n    return {\n      ssid: null,\n      isWifi: false,\n      strength: null,\n      frequency: null,\n      ipv4: null,\n      dns: null,\n      ts,\n      note: `wifi snapshot fail: ${e?.message || String(e)}`,\n    };\n  }\n}\nasync function getRadioSnapshot() {\n  const ts = new Date().toISOString();\n  try {\n    const net = await NetInfo.fetch();\n    // ✅ expo-device: pas de getApiLevelAsync ; utiliser la propriété synchrone\n    const apiLevel = Device?.platformApiLevel ?? null;\n    const brand = Device.brand ?? null;\n    const model = Device.modelName ?? null;\n    return {\n      carrier: null,\n      type: net.type ?? 'unknown',\n      cellularGeneration: net.details?.cellularGeneration ?? null,\n      isConnected: net.isConnected ?? null,\n      isInternetReachable: net.isInternetReachable ?? null,\n      apiLevel,\n      brand,\n      model,\n      ts,\n      note: !net.isConnected ? 'Device non connecté' : undefined,\n    };\n  } catch (e) {\n    return {\n      carrier: null,\n      type: 'unknown',\n      cellularGeneration: null,\n      isConnected: null,\n      isInternetReachable: null,\n      apiLevel: Device?.platformApiLevel ?? null,\n      brand: Device.brand ?? null,\n      model: Device.modelName ?? null,\n      ts,\n      note: `radio snapshot fail: ${e?.message || String(e)}`,\n    };\n  }\n}\n\n/* ----------------------- Écran principal ---------------------- */\nexport default function GrupoSinalizarScreen() {\n  const params = useLocalSearchParams(); // ✅ hook au top\n  const router = useRouter();\n  const routeParams = useMemo(() => params || {}, [params]);\n  const user = useAuthGuard();\n\n  const [toastVisible, setToastVisible] = useState(false);\n  const isRunningRef = useRef(false);\n  const watchdogRef = useRef(null);\n  const toastTimerRef = useRef(null);\n\n  const TOAST_DURATION = 6000;\n  const WATCHDOG_AFTER_COORDS_MS = 12000;\n\n  useEffect(() => {\n    console.log('[SINALIZAR][BTN] tapped → screen mounted @', new Date().toISOString());\n  }, []);\n\n  // petit handler pour démontrer l’usage des params (évite le warning “unused”)\n  const handleSomething = () => {\n    console.log('[SINALIZAR] params snapshot =', routeParams);\n  };\n\n  // GPS avec retry court\n  const getBestCoordsRetry = useCallback(async () => {\n    console.log('[SINALIZAR][PHASE] GPS/T#1 getCurrentPositionAsync…');\n    try {\n      const g1 = await withTimeout(\n        Location.getCurrentPositionAsync({\n          accuracy: Location.Accuracy.BestForNavigation,\n          mayShowUserSettingsDialog: true,\n        }),\n        7000,\n        'LOCATION_TIMEOUT_1',\n      );\n      console.log('[SINALIZAR] T#1 OK coords =', g1.coords);\n      return g1.coords;\n    } catch (e) {\n      console.log('[SINALIZAR] T#1 FAIL =', e?.message || e);\n    }\n\n    console.log('[SINALIZAR][PHASE] GPS/T#2 watchPositionAsync (2s)…');\n    return new Promise(async (resolve, reject) => {\n      let best = null;\n      let unsub = null;\n      const timer = setTimeout(() => {\n        try {\n          if (unsub) {\n            if (typeof unsub.remove === 'function') {\n              unsub.remove();\n            } else if (typeof unsub === 'function') {\n              unsub();\n            }\n          }\n        } catch {}\n        if (best) {\n          console.log('[SINALIZAR] T#2 OK best fix =', best);\n          resolve(best);\n        } else {\n          console.log('[SINALIZAR] T#2 FAIL aucun fix');\n          reject(new Error('WATCH_TIMEOUT'));\n        }\n      }, 2000);\n\n      try {\n        unsub = await Location.watchPositionAsync(\n          { accuracy: Location.Accuracy.BestForNavigation, timeInterval: 500, distanceInterval: 0 },\n          (loc) => {\n            if (loc?.coords) {\n              best = loc.coords;\n            }\n          },\n        );\n      } catch (e) {\n        clearTimeout(timer);\n        console.log('[SINALIZAR] watchPositionAsync error =', e?.message || e);\n        reject(e);\n      }\n    });\n  }, []);\n\n  // Résolution du groupId (route → user → Firestore membersIds)\n  const fetchEffectiveGroupId = useCallback(async (u, rp) => {\n    if (rp?.groupId) {\n      return String(rp.groupId);\n    }\n    const direct = u?.groupId || u?.grupoId;\n    if (direct) {\n      return String(direct);\n    }\n\n    try {\n      const uid = (u?.id ?? u?.uid ?? '').toString().trim();\n      if (!uid) {\n        console.log('[SINALIZAR][GROUP][FS] skip lookup: no uid');\n        return undefined;\n      }\n      return await lookupGroupByMembership(uid);\n    } catch (e) {\n      console.log('[SINALIZAR][GROUP][FS] lookup fail:', e?.message || e);\n      return undefined;\n    }\n  }, []);\n\n  const checkLocationAndDispatch = useCallback(async () => {\n    if (isRunningRef.current) {\n      console.log('[SINALIZAR] Ignoré (déjà en cours)');\n      return;\n    }\n    isRunningRef.current = true;\n\n    let hk = false;\n    try {\n      hk = hasGoogleKey();\n    } catch {}\n\n    console.log('[SINALIZAR][PHASE] START', {\n      hasGoogleKey: hk,\n      utilsBound: typeof resolveExactCepFromCoords === 'function',\n      userPreview: {\n        cep: user?.cep,\n        cidade: user?.cidade,\n        estado: user?.estado,\n        groupId: user?.groupId || '∅',\n      },\n    });\n\n    try {\n      // Permissions\n      console.log('[SINALIZAR][PHASE] permissions.getForeground');\n      let { status } = await withTimeout(\n        Location.getForegroundPermissionsAsync(),\n        4000,\n        'PERM_TIMEOUT_1',\n      );\n      console.log('[SINALIZAR] Permission status =', status);\n      if (status !== 'granted') {\n        console.log('[SINALIZAR][PHASE] permissions.request');\n        const ask = await withTimeout(\n          Location.requestForegroundPermissionsAsync(),\n          6000,\n          'PERM_TIMEOUT_2',\n        );\n        status = ask.status;\n        console.log('[SINALIZAR] Permission asked →', status);\n      }\n      if (status !== 'granted') {\n        Alert.alert('Permissão negada', 'Autorize a localização para sinalizar.');\n        router.replace('/(tabs)/home');\n        return;\n      }\n\n      // Coords\n      console.log('[SINALIZAR][PHASE] GPS acquire');\n      const coords = await getBestCoordsRetry();\n      console.log('[SINALIZAR] Coords finales =', coords);\n\n      // Watchdog après coords\n      if (watchdogRef.current) {\n        clearTimeout(watchdogRef.current);\n      }\n      watchdogRef.current = setTimeout(() => {\n        if (isRunningRef.current) {\n          console.log('[SINALIZAR][WATCHDOG] timeout après coords → toast + /report');\n          setToastVisible(true);\n          toastTimerRef.current = setTimeout(() => {\n            setToastVisible(false);\n            try {\n              router.replace('/report');\n            } catch {}\n          }, TOAST_DURATION);\n          isRunningRef.current = false;\n        }\n      }, WATCHDOG_AFTER_COORDS_MS);\n\n      // Signals (non bloquants)\n      try {\n        console.log('[SINALIZAR][PHASE] signals');\n        const [wifi, radio] = await withTimeout(\n          Promise.all([getWifiSnapshot(), getRadioSnapshot()]),\n          2500,\n          'SIGNALS_TIMEOUT',\n        );\n        console.log('[SINALIZAR][SIGNALS][WIFI]', wifi);\n        console.log('[SINALIZAR][SIGNALS][RADIO]', radio);\n      } catch (e) {\n        console.log('[SINALIZAR][SIGNALS] FAIL/Timeout', e?.message || e);\n      }\n\n      // User refs\n      const userCepRef = normalizeCep(user?.cep ?? user?.cepRef);\n      const userCidade = String(user?.cidade || '');\n      const userUF = toUF(user?.estado);\n\n      // Resolver CEP (Google-first)\n      console.log('[SINALIZAR][PHASE] geocode.resolve', {\n        hasKey: hk,\n        lat: coords?.latitude,\n        lng: coords?.longitude,\n      });\n      const rawRes = await withTimeout(\n        resolveExactCepFromCoords(coords.latitude, coords.longitude, {\n          googleApiKey: GOOGLE_MAPS_KEY,\n          expectedCep: userCepRef || undefined,\n          expectedCity: userCidade || undefined,\n          expectedUF: userUF || undefined,\n        }),\n        8000,\n        'CEP_TIMEOUT',\n      );\n\n      const addr = rawRes?.addr ?? rawRes?.address ?? {};\n      const currentCep8 = normalizeCep(rawRes?.cep);\n      const addrCidade = String(addr.cidade || addr.city || '');\n      const addrUF = String(addr.uf || addr.state || '');\n\n      console.log('[SINALIZAR] RESOLVE DONE →', {\n        cep: rawRes?.cep,\n        provider: rawRes?.provider,\n        candidates: Array.isArray(rawRes?.candidates) ? rawRes.candidates.length : 0,\n        addr,\n      });\n\n      // Hydrate groupId\n      const effectiveGroupId = await fetchEffectiveGroupId(user, routeParams);\n      console.log('[SINALIZAR][GROUP] effectiveGroupId =', effectiveGroupId || '∅');\n\n      // fallback par CEP\n      let finalGroupId = effectiveGroupId;\n      if (!finalGroupId) {\n        if (userCepRef) {\n          const g1 = await lookupGroupByCep(userCepRef);\n          if (g1) {\n            finalGroupId = g1.id;\n          }\n        }\n        if (!finalGroupId && currentCep8) {\n          const g2 = await lookupGroupByCep(currentCep8);\n          if (g2) {\n            finalGroupId = g2.id;\n          }\n        }\n      }\n\n      console.log('[SINALIZAR][CEP] profile=', userCepRef, '| geo=', currentCep8);\n      const inSame = sameZone(currentCep8, userCepRef, addrCidade, addrUF, userCidade, userUF);\n      const hasGroup = !!finalGroupId;\n      console.log('[SINALIZAR][ZONE] sameZone =', inSame);\n      console.log('[SINALIZAR][GROUP] hasGroup =', hasGroup);\n\n      if (!hasGroup) {\n        console.log('[SINALIZAR][DECISION] PAS de groupe → public (toast + /report)');\n        setToastVisible(true);\n        toastTimerRef.current = setTimeout(() => {\n          setToastVisible(false);\n          router.replace('/report');\n        }, TOAST_DURATION);\n        return;\n      }\n\n      if (hasGroup && inSame) {\n        console.log('[SINALIZAR][DECISION] AVEC groupe & CHEZ SOI → modale (privé/public)');\n        Alert.alert(\n          'Tipo de alerta',\n          'Como deseja sinalizar?',\n          [\n            {\n              text: 'Para vizinhos (grupo)',\n              onPress: () => {\n                console.log('[SINALIZAR] Choix: groupe → /grupo-report');\n                router.replace({\n                  pathname: '/grupo-report',\n                  params: {\n                    groupId: finalGroupId,\n                    cep: userCepRef || currentCep8 || '',\n                    cidade: addrCidade || userCidade || '',\n                    estado: addrUF || userUF || '',\n                  },\n                });\n              },\n            },\n            {\n              text: 'Público',\n              onPress: () => {\n                console.log('[SINALIZAR] Choix: public → /report');\n                router.replace('/report');\n              },\n            },\n            {\n              text: 'Cancelar',\n              style: 'cancel',\n              onPress: () => {\n                console.log('[SINALIZAR] Choix: annuler → /home');\n                router.replace('/(tabs)/home');\n              },\n            },\n          ],\n          { cancelable: true },\n        );\n      } else {\n        console.log('[SINALIZAR][DECISION] AVEC groupe MAIS HORS ZONE → public (toast + /report)', {\n          currentCep8,\n          userCepRef,\n          addrCidade,\n          addrUF,\n          userCidade,\n          userUF,\n        });\n        setToastVisible(true);\n        toastTimerRef.current = setTimeout(() => {\n          setToastVisible(false);\n          router.replace('/report');\n        }, TOAST_DURATION);\n      }\n    } catch (err) {\n      console.log('[SINALIZAR] ERREUR (main) =', err?.message || err);\n      Alert.alert('Erro', 'Não foi possível obter sua localização.');\n      router.replace('/(tabs)/home');\n    } finally {\n      if (watchdogRef.current) {\n        clearTimeout(watchdogRef.current);\n      }\n      if (toastTimerRef.current) {\n        clearTimeout(toastTimerRef.current);\n      }\n      isRunningRef.current = false;\n      console.log('[SINALIZAR][PHASE] END');\n    }\n  }, [router, routeParams, user, getBestCoordsRetry, fetchEffectiveGroupId]);\n\n  useEffect(() => {\n    if (user) {\n      console.log('[SINALIZAR] useEffect → checkLocationAndDispatch()');\n      checkLocationAndDispatch();\n    }\n  }, [user, checkLocationAndDispatch]);\n\n  return (\n    <View style={styles.container}>\n      <PhoneSatelliteLoader />\n      {toastVisible && (\n        <CustomTopToast\n          text1=\"📍 Fora da sua zona de vizinhança – sinalização pública apenas.\"\n          duration={TOAST_DURATION}\n          textColor=\"#FFD600\"\n          containerStyle={{ marginTop: 60 }}\n        />\n      )}\n\n      {/* petit bouton invisible de debug pour consommer params */}\n      <TouchableOpacity onPress={handleSomething} style={{ padding: 8 }}>\n        <Text style={{ color: '#8b949e', fontSize: 12 }}>debug: log params</Text>\n      </TouchableOpacity>\n    </View>\n  );\n}\n\n/* ----------------------------- Styles ----------------------------- */\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#0D1117',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n  },\n  loaderWrap: {\n    width: '100%',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: 30,\n  },\n  loaderText: { color: '#D0D7DE', marginTop: 18, fontSize: 16 },\n  phone: {\n    width: 84,\n    height: 150,\n    borderRadius: 20,\n    backgroundColor: '#161B22',\n    borderWidth: 2,\n    borderColor: '#30363D',\n    alignItems: 'center',\n    justifyContent: 'center',\n    shadowColor: '#000',\n    shadowOpacity: 0.25,\n    shadowRadius: 10,\n    shadowOffset: { width: 0, height: 6 },\n  },\n  phoneScreen: { width: 66, height: 120, borderRadius: 14, backgroundColor: '#0B1220' },\n  satOrbit: {\n    position: 'absolute',\n    width: 220,\n    height: 220,\n    borderRadius: 110,\n    borderWidth: 1,\n    borderColor: 'rgba(88,166,255,0.25)',\n    alignItems: 'center',\n    justifyContent: 'flex-start',\n  },\n  satBody: {\n    width: 34,\n    height: 22,\n    marginTop: 8,\n    backgroundColor: '#58A6FF',\n    borderRadius: 4,\n    alignItems: 'center',\n    justifyContent: 'center',\n    flexDirection: 'row',\n    shadowColor: '#58A6FF',\n    shadowOpacity: 0.5,\n    shadowRadius: 6,\n  },\n  satPanel: {\n    position: 'absolute',\n    left: -14,\n    width: 12,\n    height: 18,\n    borderRadius: 2,\n    backgroundColor: '#1F6FEB',\n  },\n  wave: {\n    position: 'absolute',\n    width: 260,\n    height: 260,\n    borderRadius: 130,\n    borderWidth: 2,\n    borderColor: 'rgba(56,139,253,0.25)',\n  },\n});\n"
    }
  ]
}
