{
  "sourceFile": "app/_layout.jsx",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 4,
      "patches": [
        {
          "date": 1758950164997,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        },
        {
          "date": 1758950790255,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,22 +6,22 @@\n  - Guards sur Firestore/CEP + masking tokens\n  - ErrorBoundary + logs horodatés\n ============================================================= */\n \n-import { StripeProvider } from \"@stripe/stripe-react-native\";\n-import Constants from \"expo-constants\";\n-import { Stack } from \"expo-router\";\n-import React, { useEffect, useRef } from \"react\";\n-import { ErrorBoundary } from \"react-error-boundary\";\n-import { Text, View, Platform } from \"react-native\";\n-import { GestureHandlerRootView } from \"react-native-gesture-handler\";\n-import { Provider as PaperProvider } from \"react-native-paper\";\n-import { SafeAreaProvider, useSafeAreaInsets } from \"react-native-safe-area-context\";\n-import Toast from \"react-native-toast-message\";\n-import * as Application from \"expo-application\";\n+import { StripeProvider } from '@stripe/stripe-react-native';\n+import Constants from 'expo-constants';\n+import { Stack } from 'expo-router';\n+import React, { useEffect, useRef } from 'react';\n+import { ErrorBoundary } from 'react-error-boundary';\n+import { Text, View, Platform } from 'react-native';\n+import { GestureHandlerRootView } from 'react-native-gesture-handler';\n+import { Provider as PaperProvider } from 'react-native-paper';\n+import { SafeAreaProvider, useSafeAreaInsets } from 'react-native-safe-area-context';\n+import Toast from 'react-native-toast-message';\n+import * as Application from 'expo-application';\n \n-import \"../src/_bootstrap/monetization-init\";\n-import CustomTopToast from \"./components/CustomTopToast\";\n+import '../src/_bootstrap/monetization-init';\n+import CustomTopToast from './components/CustomTopToast';\n \n // 🔔 Notifications\n import {\n   attachNotificationListeners,\n@@ -29,20 +29,20 @@\n   registerForPushNotificationsAsync,\n   ensureAndroidChannels,\n   initNotifications,\n   wireAuthGateForNotifications,\n-} from \"../libs/notifications\";\n+} from '../libs/notifications';\n \n // Backend device upsert\n-import { upsertDevice } from \"../libs/registerDevice\";\n+import { upsertDevice } from '../libs/registerDevice';\n \n // Firebase\n-import { onAuthStateChanged } from \"firebase/auth\";\n-import { doc, getDoc, getFirestore } from \"firebase/firestore\";\n-import { auth } from \"../firebase\";\n+import { onAuthStateChanged } from 'firebase/auth';\n+import { doc, getDoc, getFirestore } from 'firebase/firestore';\n+import { auth } from '../firebase';\n \n // Store\n-import { useUserStore } from \"../store/users\";\n+import { useUserStore } from '../store/users';\n \n /** Fallback extra (EAS/production friendly) */\n const extra =\n   (Constants && Constants.expoConfig && Constants.expoConfig.extra) ||\n@@ -50,10 +50,10 @@\n   (Constants && Constants.manifest && Constants.manifest.extra) ||\n   {};\n \n const SILENCE_RELEASE = !!extra.SILENCE_CONSOLE_IN_RELEASE;\n-const APP_TAG = \"VigiApp\";\n-const LAYOUT_TAG = \"PushBootstrap\";\n+const APP_TAG = 'VigiApp';\n+const LAYOUT_TAG = 'PushBootstrap';\n \n // Horodatage compact et safe\n function ts() {\n   try {\n@@ -84,11 +84,11 @@\n   } catch {}\n }\n \n // Polyfill Hermes (shallow clone via JSON — attention aux types non sérialisables)\n-if (typeof global.structuredClone !== \"function\") {\n+if (typeof global.structuredClone !== 'function') {\n   global.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));\n-  log(\"structuredClone polyfilled\");\n+  log('structuredClone polyfilled');\n }\n \n // En release : on peut réduire le bruit, mais on NE coupe PAS console.error\n if (!__DEV__ && SILENCE_RELEASE) {\n@@ -102,50 +102,50 @@\n }\n \n // UI fallback de l’ErrorBoundary\n function MyFallback({ error }) {\n-  err(\"ErrorBoundary caught:\", error && error.message, error && error.stack);\n+  err('ErrorBoundary caught:', error && error.message, error && error.stack);\n   return (\n     <View\n       style={{\n         flex: 1,\n-        justifyContent: \"center\",\n-        alignItems: \"center\",\n-        backgroundColor: \"#181A20\",\n+        justifyContent: 'center',\n+        alignItems: 'center',\n+        backgroundColor: '#181A20',\n         paddingHorizontal: 24,\n       }}\n     >\n-      <Text style={{ color: \"#FFD600\", fontWeight: \"bold\", fontSize: 20, marginBottom: 12 }}>\n+      <Text style={{ color: '#FFD600', fontWeight: 'bold', fontSize: 20, marginBottom: 12 }}>\n         Oops!\n       </Text>\n-      <Text style={{ color: \"#fff\", textAlign: \"center\", fontSize: 16, marginBottom: 8 }}>\n-        {(error && error.message) || \"Une erreur est survenue.\"}\n+      <Text style={{ color: '#fff', textAlign: 'center', fontSize: 16, marginBottom: 8 }}>\n+        {(error && error.message) || 'Une erreur est survenue.'}\n       </Text>\n-      <Text style={{ color: \"#aaa\", fontSize: 12, textAlign: \"center\" }}>\n+      <Text style={{ color: '#aaa', fontSize: 12, textAlign: 'center' }}>\n         Essaie de relancer l’application.\n       </Text>\n     </View>\n   );\n }\n \n function mapSeverityToToastType(sev) {\n-  const s = String(sev || \"\").toLowerCase();\n-  if (s === \"high\" || s === \"grave\") return \"error\";\n-  if (s === \"low\" || s === \"minor\") return \"success\";\n-  return \"info\";\n+  const s = String(sev || '').toLowerCase();\n+  if (s === 'high' || s === 'grave') {return 'error';}\n+  if (s === 'low' || s === 'minor') {return 'success';}\n+  return 'info';\n }\n \n // Firestore: récup CEP au besoin (fallback unique par uid)\n async function fetchUserCepFromFirestore(uid) {\n   try {\n     const db = getFirestore();\n-    const ref = doc(db, \"users\", uid);\n+    const ref = doc(db, 'users', uid);\n     const snap = await getDoc(ref);\n-    const cep = snap.exists() ? (snap.data() && (snap.data().cep ?? null)) : null;\n-    log(\"[fallback] Firestore CEP =\", cep || \"(none)\");\n+    const cep = snap.exists() ? snap.data() && (snap.data().cep ?? null) : null;\n+    log('[fallback] Firestore CEP =', cep || '(none)');\n     return cep ? String(cep) : null;\n   } catch (e) {\n-    warn(\"[fallback] Firestore CEP error:\", (e && e.message) || e);\n+    warn('[fallback] Firestore CEP error:', (e && e.message) || e);\n     return null;\n   }\n }\n \n@@ -153,13 +153,13 @@\n function safeJson(obj) {\n   try {\n     return JSON.stringify(obj).slice(0, 1000);\n   } catch {\n-    return \"[unserializable]\";\n+    return '[unserializable]';\n   }\n }\n function maskToken(tok) {\n-  if (!tok) return tok;\n+  if (!tok) {return tok;}\n   const s = String(tok);\n   return s.length <= 12 ? s : `${s.slice(0, 12)}…(${s.length})`;\n }\n \n@@ -183,47 +183,47 @@\n // Composant “headless” qui fait tout le bootstrap notifs + upsert device\n function PushBootstrap() {\n   const expoTokenRef = useRef(null);\n   const fcmTokenRef = useRef(null);\n-  const lastUpsertKeyRef = useRef(\"\");\n-  const triedFallbackForUidRef = useRef(\"\"); // évite Firestore fallback multiple\n+  const lastUpsertKeyRef = useRef('');\n+  const triedFallbackForUidRef = useRef(''); // évite Firestore fallback multiple\n   const { user } = useUserStore();\n \n   // A) Infra notifications + listeners — une seule fois au montage\n   useEffect(() => {\n     let detachListeners = () => {};\n     (async () => {\n       const t0 = Date.now();\n-      log(\"mount → start bootstrap\");\n+      log('mount → start bootstrap');\n \n       // 🔐 Lie notifs ↔ auth (navigation après tap notif quand app fermée)\n       try {\n         wireAuthGateForNotifications(auth);\n       } catch (e) {\n-        warn(\"wireAuthGateForNotifications error:\", (e && e.message) || e);\n+        warn('wireAuthGateForNotifications error:', (e && e.message) || e);\n       }\n \n       // Android : canaux D’ABORD, puis init (perms, cold start)\n       try {\n         await ensureAndroidChannels();\n       } catch (e) {\n-        warn(\"ensureAndroidChannels error:\", (e && e.message) || e);\n+        warn('ensureAndroidChannels error:', (e && e.message) || e);\n       }\n \n       try {\n         await initNotifications();\n-        log(\"initNotifications ok\");\n+        log('initNotifications ok');\n       } catch (e) {\n-        warn(\"initNotifications error:\", (e && e.message) || e);\n+        warn('initNotifications error:', (e && e.message) || e);\n       }\n \n       // a) Listeners\n       try {\n         const maybeDetach = attachNotificationListeners({\n           onReceive: (n) => {\n             const content = (n && n.request && n.request.content) || {};\n-            const title = content.title || \"VigiApp\";\n-            const body = content.body || \"\";\n+            const title = content.title || 'VigiApp';\n+            const body = content.body || '';\n             const sev =\n               (content.data && (content.data.severidade || content.data.severity)) || undefined;\n             const type = mapSeverityToToastType(sev);\n             const line = body ? `${title} — ${body}` : title;\n@@ -232,13 +232,13 @@\n               content.image ||\n               content.imageUrl ||\n               null;\n \n-            log(\"listener:onReceive\", safeJson({ title, data: content.data }));\n+            log('listener:onReceive', safeJson({ title, data: content.data }));\n             Toast.show({\n               type,\n               text1: line,\n-              position: \"top\",\n+              position: 'top',\n               visibilityTime: 8000,\n               autoHide: true,\n               props: { imageUrl },\n             });\n@@ -249,58 +249,58 @@\n               r.notification &&\n               r.notification.request &&\n               r.notification.request.content &&\n               r.notification.request.content.data;\n-            log(\"listener:onResponse\", safeJson({ data }));\n+            log('listener:onResponse', safeJson({ data }));\n           },\n         });\n-        detachListeners = typeof maybeDetach === \"function\" ? maybeDetach : () => {};\n-        log(\"listeners attached\");\n+        detachListeners = typeof maybeDetach === 'function' ? maybeDetach : () => {};\n+        log('listeners attached');\n       } catch (e) {\n-        err(\"attachNotificationListeners failed:\", (e && e.message) || e);\n+        err('attachNotificationListeners failed:', (e && e.message) || e);\n       }\n \n       // b) Permissions + Expo push token\n       try {\n         const expoTok = await registerForPushNotificationsAsync();\n         expoTokenRef.current = expoTok || null;\n-        log(\"expo token obtained:\", maskToken(expoTok));\n+        log('expo token obtained:', maskToken(expoTok));\n       } catch (e) {\n-        warn(\"registerForPushNotificationsAsync error:\", (e && e.message) || e);\n+        warn('registerForPushNotificationsAsync error:', (e && e.message) || e);\n       }\n \n       // c) FCM device token (peut arriver en retard)\n       try {\n         let fcmTok = await getFcmDeviceTokenAsync();\n         fcmTokenRef.current = fcmTok || null;\n-        log(\"fcm token obtained:\", maskToken(fcmTok));\n+        log('fcm token obtained:', maskToken(fcmTok));\n         if (!fcmTok) {\n           setTimeout(async () => {\n             try {\n               const retry = await getFcmDeviceTokenAsync();\n               if (retry) {\n                 fcmTokenRef.current = retry;\n-                log(\"fcm token late obtained:\", maskToken(retry));\n+                log('fcm token late obtained:', maskToken(retry));\n               }\n             } catch {}\n           }, 2500);\n         }\n       } catch (e) {\n-        warn(\"getFcmDeviceTokenAsync error:\", (e && e.message) || e);\n+        warn('getFcmDeviceTokenAsync error:', (e && e.message) || e);\n       }\n \n       const dt = Date.now() - t0;\n-      log(\"bootstrap completed in\", `${dt}ms`);\n+      log('bootstrap completed in', `${dt}ms`);\n     })();\n \n     // Cleanup strict-mode safe\n     return () => {\n-      log(\"unmount → cleanup…\");\n+      log('unmount → cleanup…');\n       try {\n         detachListeners && detachListeners();\n-        log(\"listeners detached\");\n+        log('listeners detached');\n       } catch (e) {\n-        err(\"detach listeners error:\", (e && e.message) || e);\n+        err('detach listeners error:', (e && e.message) || e);\n       }\n     };\n   }, []); // montage unique\n \n@@ -310,90 +310,90 @@\n     (async () => {\n       try {\n         const unsub = onAuthStateChanged(auth, async (fbUser) => {\n           if (!fbUser) {\n-            log(\"auth: signed out (no upsert)\");\n+            log('auth: signed out (no upsert)');\n             return;\n           }\n           if (!expoTokenRef.current && !fcmTokenRef.current) {\n-            warn(\"auth: user present but no tokens yet (will upsert later)\");\n+            warn('auth: user present but no tokens yet (will upsert later)');\n             return;\n           }\n \n           // CEP depuis store, sinon fallback Firestore (1x/uid)\n           let cep = user && user.cep ? String(user.cep) : null;\n-          log(\"auth: CEP from store =\", cep || \"(none)\");\n+          log('auth: CEP from store =', cep || '(none)');\n \n           if (!cep && triedFallbackForUidRef.current !== fbUser.uid) {\n             triedFallbackForUidRef.current = fbUser.uid;\n             cep = await fetchUserCepFromFirestore(fbUser.uid);\n           }\n           if (!cep) {\n-            warn(\"auth: CEP missing → skip device upsert\");\n+            warn('auth: CEP missing → skip device upsert');\n             return;\n           }\n \n           // Idempotence via clé (uid + prefixes tokens)\n-          const key = `${fbUser.uid}:${String(expoTokenRef.current || \"\").slice(0, 12)}:${String(\n-            fcmTokenRef.current || \"\"\n+          const key = `${fbUser.uid}:${String(expoTokenRef.current || '').slice(0, 12)}:${String(\n+            fcmTokenRef.current || '',\n           ).slice(0, 12)}`;\n           if (lastUpsertKeyRef.current === key) {\n-            log(\"auth: upsert skipped (same uid+tokens prefix)\", key);\n+            log('auth: upsert skipped (same uid+tokens prefix)', key);\n             return;\n           }\n \n-          log(\"auth: signed in → upsert device…\", { uid: fbUser.uid, key, cep });\n+          log('auth: signed in → upsert device…', { uid: fbUser.uid, key, cep });\n           try {\n             const res = await upsertDevice({\n               userId: fbUser.uid,\n               expoPushToken: expoTokenRef.current,\n               fcmDeviceToken: fcmTokenRef.current,\n               cep,\n               appVersion:\n                 Application.nativeApplicationVersion ||\n-                Application.applicationVersion ||\n-                \"0\",\n+                (await Application.getApplicationVersionAsync()) ||\n+                '0',\n               platform: Platform.OS,\n             });\n             if (res && res.ok) {\n-              log(\"upsert success:\", (res && res.id) || \"(no id)\");\n+              log('upsert success:', (res && res.id) || '(no id)');\n               lastUpsertKeyRef.current = key;\n             } else {\n-              warn(\"upsert returned not ok:\", (res && res.error) || \"unknown\");\n+              warn('upsert returned not ok:', (res && res.error) || 'unknown');\n             }\n           } catch (e) {\n-            err(\"upsert failed:\", (e && e.message) || e);\n+            err('upsert failed:', (e && e.message) || e);\n           }\n         });\n-        unsubscribeAuth = typeof unsub === \"function\" ? unsub : undefined;\n-        log(\"auth listener attached (upsert)\");\n+        unsubscribeAuth = typeof unsub === 'function' ? unsub : undefined;\n+        log('auth listener attached (upsert)');\n       } catch (e) {\n-        err(\"attach onAuthStateChanged failed (upsert effect):\", (e && e.message) || e);\n+        err('attach onAuthStateChanged failed (upsert effect):', (e && e.message) || e);\n       }\n     })();\n \n     return () => {\n       try {\n         unsubscribeAuth && unsubscribeAuth();\n-        log(\"auth listener detached (upsert)\");\n+        log('auth listener detached (upsert)');\n       } catch (e) {\n-        err(\"detach auth error:\", (e && e.message) || e);\n+        err('detach auth error:', (e && e.message) || e);\n       }\n     };\n   }, [user && user.cep]);\n \n   return null;\n }\n \n export default function Layout() {\n-  const publishableKey = String(extra.STRIPE_PUBLISHABLE_KEY || \"\");\n+  const publishableKey = String(extra.STRIPE_PUBLISHABLE_KEY || '');\n   if (!publishableKey) {\n-    warn(\"Stripe publishableKey is empty in extra.STRIPE_PUBLISHABLE_KEY\");\n+    warn('Stripe publishableKey is empty in extra.STRIPE_PUBLISHABLE_KEY');\n   } else {\n-    log(\"Stripe key present (masked len):\", `${String(publishableKey).length} chars`);\n+    log('Stripe key present (masked len):', `${String(publishableKey).length} chars`);\n   }\n \n-  log(\"Layout render\");\n+  log('Layout render');\n \n   return (\n     <SafeAreaProvider>\n       <GestureHandlerRootView style={{ flex: 1 }}>\n"
        },
        {
          "date": 1758950804379,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,418 @@\n+/* =============================================================\n+ VigiApp — Root layout (Push bootstrap robuste, prod-ready en dev)\n+ - Android : ensure channels AVANT demande de permissions\n+ - Listeners toujours détachables (fallback no-op)\n+ - Ne JAMAIS couper console.error (même en release)\n+ - Guards sur Firestore/CEP + masking tokens\n+ - ErrorBoundary + logs horodatés\n+============================================================= */\n+\n+import { StripeProvider } from '@stripe/stripe-react-native';\n+import Constants from 'expo-constants';\n+import { Stack } from 'expo-router';\n+import React, { useEffect, useRef } from 'react';\n+import { ErrorBoundary } from 'react-error-boundary';\n+import { Text, View, Platform } from 'react-native';\n+import { GestureHandlerRootView } from 'react-native-gesture-handler';\n+import { Provider as PaperProvider } from 'react-native-paper';\n+import { SafeAreaProvider, useSafeAreaInsets } from 'react-native-safe-area-context';\n+import Toast from 'react-native-toast-message';\n+import * as Application from 'expo-application';\n+\n+import '../src/_bootstrap/monetization-init';\n+import CustomTopToast from './components/CustomTopToast';\n+\n+// 🔔 Notifications\n+import {\n+  attachNotificationListeners,\n+  getFcmDeviceTokenAsync,\n+  registerForPushNotificationsAsync,\n+  ensureAndroidChannels,\n+  initNotifications,\n+  wireAuthGateForNotifications,\n+} from '../libs/notifications';\n+\n+// Backend device upsert\n+import { upsertDevice } from '../libs/registerDevice';\n+\n+// Firebase\n+import { onAuthStateChanged } from 'firebase/auth';\n+import { doc, getDoc, getFirestore } from 'firebase/firestore';\n+import { auth } from '../firebase';\n+\n+// Store\n+import { useUserStore } from '../store/users';\n+\n+/** Fallback extra (EAS/production friendly) */\n+const extra =\n+  (Constants && Constants.expoConfig && Constants.expoConfig.extra) ||\n+  (Constants && Constants.manifestExtra) ||\n+  (Constants && Constants.manifest && Constants.manifest.extra) ||\n+  {};\n+\n+const SILENCE_RELEASE = !!extra.SILENCE_CONSOLE_IN_RELEASE;\n+const APP_TAG = 'VigiApp';\n+const LAYOUT_TAG = 'PushBootstrap';\n+\n+// Horodatage compact et safe\n+function ts() {\n+  try {\n+    return new Date().toISOString();\n+  } catch {\n+    return String(Date.now());\n+  }\n+}\n+\n+// Logger centralisé (ne coupe pas .error en prod)\n+function log(...a) {\n+  if (__DEV__ || !SILENCE_RELEASE) {\n+    try {\n+      console.log(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n+    } catch {}\n+  }\n+}\n+function warn(...a) {\n+  if (__DEV__ || !SILENCE_RELEASE) {\n+    try {\n+      console.warn(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n+    } catch {}\n+  }\n+}\n+function err(...a) {\n+  try {\n+    console.error(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n+  } catch {}\n+}\n+\n+// Polyfill Hermes (shallow clone via JSON — attention aux types non sérialisables)\n+if (typeof global.structuredClone !== 'function') {\n+  global.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));\n+  log('structuredClone polyfilled');\n+}\n+\n+// En release : on peut réduire le bruit, mais on NE coupe PAS console.error\n+if (!__DEV__ && SILENCE_RELEASE) {\n+  try {\n+    console.log = () => {};\n+  } catch {}\n+  try {\n+    console.warn = () => {};\n+  } catch {}\n+  // console.error RESTE actif\n+}\n+\n+// UI fallback de l’ErrorBoundary\n+function MyFallback({ error }) {\n+  err('ErrorBoundary caught:', error && error.message, error && error.stack);\n+  return (\n+    <View\n+      style={{\n+        flex: 1,\n+        justifyContent: 'center',\n+        alignItems: 'center',\n+        backgroundColor: '#181A20',\n+        paddingHorizontal: 24,\n+      }}\n+    >\n+      <Text style={{ color: '#FFD600', fontWeight: 'bold', fontSize: 20, marginBottom: 12 }}>\n+        Oops!\n+      </Text>\n+      <Text style={{ color: '#fff', textAlign: 'center', fontSize: 16, marginBottom: 8 }}>\n+        {(error && error.message) || 'Une erreur est survenue.'}\n+      </Text>\n+      <Text style={{ color: '#aaa', fontSize: 12, textAlign: 'center' }}>\n+        Essaie de relancer l’application.\n+      </Text>\n+    </View>\n+  );\n+}\n+\n+function mapSeverityToToastType(sev) {\n+  const s = String(sev || '').toLowerCase();\n+  if (s === 'high' || s === 'grave') {return 'error';}\n+  if (s === 'low' || s === 'minor') {return 'success';}\n+  return 'info';\n+}\n+\n+// Firestore: récup CEP au besoin (fallback unique par uid)\n+async function fetchUserCepFromFirestore(uid) {\n+  try {\n+    const db = getFirestore();\n+    const ref = doc(db, 'users', uid);\n+    const snap = await getDoc(ref);\n+    const cep = snap.exists() ? snap.data() && (snap.data().cep ?? null) : null;\n+    log('[fallback] Firestore CEP =', cep || '(none)');\n+    return cep ? String(cep) : null;\n+  } catch (e) {\n+    warn('[fallback] Firestore CEP error:', (e && e.message) || e);\n+    return null;\n+  }\n+}\n+\n+// Utils logs\n+function safeJson(obj) {\n+  try {\n+    return JSON.stringify(obj).slice(0, 1000);\n+  } catch {\n+    return '[unserializable]';\n+  }\n+}\n+function maskToken(tok) {\n+  if (!tok) {return tok;}\n+  const s = String(tok);\n+  return s.length <= 12 ? s : `${s.slice(0, 12)}…(${s.length})`;\n+}\n+\n+/** Toast global tenant compte du safe-area top */\n+function GlobalToasts() {\n+  const insets = useSafeAreaInsets();\n+  return (\n+    <Toast\n+      config={{\n+        success: (props) => <CustomTopToast {...props} />,\n+        info: (props) => <CustomTopToast {...props} />,\n+        error: (props) => <CustomTopToast {...props} />,\n+        default: (props) => <CustomTopToast {...props} />,\n+      }}\n+      position=\"top\"\n+      topOffset={Math.max(10, insets.top)}\n+    />\n+  );\n+}\n+\n+// Composant “headless” qui fait tout le bootstrap notifs + upsert device\n+function PushBootstrap() {\n+  const expoTokenRef = useRef(null);\n+  const fcmTokenRef = useRef(null);\n+  const lastUpsertKeyRef = useRef('');\n+  const triedFallbackForUidRef = useRef(''); // évite Firestore fallback multiple\n+  const { user } = useUserStore();\n+\n+  // A) Infra notifications + listeners — une seule fois au montage\n+  useEffect(() => {\n+    let detachListeners = () => {};\n+    (async () => {\n+      const t0 = Date.now();\n+      log('mount → start bootstrap');\n+\n+      // 🔐 Lie notifs ↔ auth (navigation après tap notif quand app fermée)\n+      try {\n+        wireAuthGateForNotifications(auth);\n+      } catch (e) {\n+        warn('wireAuthGateForNotifications error:', (e && e.message) || e);\n+      }\n+\n+      // Android : canaux D’ABORD, puis init (perms, cold start)\n+      try {\n+        await ensureAndroidChannels();\n+      } catch (e) {\n+        warn('ensureAndroidChannels error:', (e && e.message) || e);\n+      }\n+\n+      try {\n+        await initNotifications();\n+        log('initNotifications ok');\n+      } catch (e) {\n+        warn('initNotifications error:', (e && e.message) || e);\n+      }\n+\n+      // a) Listeners\n+      try {\n+        const maybeDetach = attachNotificationListeners({\n+          onReceive: (n) => {\n+            const content = (n && n.request && n.request.content) || {};\n+            const title = content.title || 'VigiApp';\n+            const body = content.body || '';\n+            const sev =\n+              (content.data && (content.data.severidade || content.data.severity)) || undefined;\n+            const type = mapSeverityToToastType(sev);\n+            const line = body ? `${title} — ${body}` : title;\n+            const imageUrl =\n+              (content.data && (content.data.image || content.data.imageUrl)) ||\n+              content.image ||\n+              content.imageUrl ||\n+              null;\n+\n+            log('listener:onReceive', safeJson({ title, data: content.data }));\n+            Toast.show({\n+              type,\n+              text1: line,\n+              position: 'top',\n+              visibilityTime: 8000,\n+              autoHide: true,\n+              props: { imageUrl },\n+            });\n+          },\n+          onResponse: (r) => {\n+            const data =\n+              r &&\n+              r.notification &&\n+              r.notification.request &&\n+              r.notification.request.content &&\n+              r.notification.request.content.data;\n+            log('listener:onResponse', safeJson({ data }));\n+          },\n+        });\n+        detachListeners = typeof maybeDetach === 'function' ? maybeDetach : () => {};\n+        log('listeners attached');\n+      } catch (e) {\n+        err('attachNotificationListeners failed:', (e && e.message) || e);\n+      }\n+\n+      // b) Permissions + Expo push token\n+      try {\n+        const expoTok = await registerForPushNotificationsAsync();\n+        expoTokenRef.current = expoTok || null;\n+        log('expo token obtained:', maskToken(expoTok));\n+      } catch (e) {\n+        warn('registerForPushNotificationsAsync error:', (e && e.message) || e);\n+      }\n+\n+      // c) FCM device token (peut arriver en retard)\n+      try {\n+        let fcmTok = await getFcmDeviceTokenAsync();\n+        fcmTokenRef.current = fcmTok || null;\n+        log('fcm token obtained:', maskToken(fcmTok));\n+        if (!fcmTok) {\n+          setTimeout(async () => {\n+            try {\n+              const retry = await getFcmDeviceTokenAsync();\n+              if (retry) {\n+                fcmTokenRef.current = retry;\n+                log('fcm token late obtained:', maskToken(retry));\n+              }\n+            } catch {}\n+          }, 2500);\n+        }\n+      } catch (e) {\n+        warn('getFcmDeviceTokenAsync error:', (e && e.message) || e);\n+      }\n+\n+      const dt = Date.now() - t0;\n+      log('bootstrap completed in', `${dt}ms`);\n+    })();\n+\n+    // Cleanup strict-mode safe\n+    return () => {\n+      log('unmount → cleanup…');\n+      try {\n+        detachListeners && detachListeners();\n+        log('listeners detached');\n+      } catch (e) {\n+        err('detach listeners error:', (e && e.message) || e);\n+      }\n+    };\n+  }, []); // montage unique\n+\n+  // B) Upsert device — réagit à user?.cep + tokens + auth\n+  useEffect(() => {\n+    let unsubscribeAuth;\n+    (async () => {\n+      try {\n+        const unsub = onAuthStateChanged(auth, async (fbUser) => {\n+          if (!fbUser) {\n+            log('auth: signed out (no upsert)');\n+            return;\n+          }\n+          if (!expoTokenRef.current && !fcmTokenRef.current) {\n+            warn('auth: user present but no tokens yet (will upsert later)');\n+            return;\n+          }\n+\n+          // CEP depuis store, sinon fallback Firestore (1x/uid)\n+          let cep = user && user.cep ? String(user.cep) : null;\n+          log('auth: CEP from store =', cep || '(none)');\n+\n+          if (!cep && triedFallbackForUidRef.current !== fbUser.uid) {\n+            triedFallbackForUidRef.current = fbUser.uid;\n+            cep = await fetchUserCepFromFirestore(fbUser.uid);\n+          }\n+          if (!cep) {\n+            warn('auth: CEP missing → skip device upsert');\n+            return;\n+          }\n+\n+          // Idempotence via clé (uid + prefixes tokens)\n+          const key = `${fbUser.uid}:${String(expoTokenRef.current || '').slice(0, 12)}:${String(\n+            fcmTokenRef.current || '',\n+          ).slice(0, 12)}`;\n+          if (lastUpsertKeyRef.current === key) {\n+            log('auth: upsert skipped (same uid+tokens prefix)', key);\n+            return;\n+          }\n+\n+          log('auth: signed in → upsert device…', { uid: fbUser.uid, key, cep });\n+          try {\n+            const res = await upsertDevice({\n+              userId: fbUser.uid,\n+              expoPushToken: expoTokenRef.current,\n+              fcmDeviceToken: fcmTokenRef.current,\n+              cep,\n+              appVersion:\n+                Application.nativeApplicationVersion ||\n+                (await Application.getApplicationNameAsync()) ||\n+                '0',\n+              platform: Platform.OS,\n+            });\n+            if (res && res.ok) {\n+              log('upsert success:', (res && res.id) || '(no id)');\n+              lastUpsertKeyRef.current = key;\n+            } else {\n+              warn('upsert returned not ok:', (res && res.error) || 'unknown');\n+            }\n+          } catch (e) {\n+            err('upsert failed:', (e && e.message) || e);\n+          }\n+        });\n+        unsubscribeAuth = typeof unsub === 'function' ? unsub : undefined;\n+        log('auth listener attached (upsert)');\n+      } catch (e) {\n+        err('attach onAuthStateChanged failed (upsert effect):', (e && e.message) || e);\n+      }\n+    })();\n+\n+    return () => {\n+      try {\n+        unsubscribeAuth && unsubscribeAuth();\n+        log('auth listener detached (upsert)');\n+      } catch (e) {\n+        err('detach auth error:', (e && e.message) || e);\n+      }\n+    };\n+  }, [user && user.cep]);\n+\n+  return null;\n+}\n+\n+export default function Layout() {\n+  const publishableKey = String(extra.STRIPE_PUBLISHABLE_KEY || '');\n+  if (!publishableKey) {\n+    warn('Stripe publishableKey is empty in extra.STRIPE_PUBLISHABLE_KEY');\n+  } else {\n+    log('Stripe key present (masked len):', `${String(publishableKey).length} chars`);\n+  }\n+\n+  log('Layout render');\n+\n+  return (\n+    <SafeAreaProvider>\n+      <GestureHandlerRootView style={{ flex: 1 }}>\n+        <PaperProvider>\n+          <StripeProvider publishableKey={publishableKey}>\n+            <ErrorBoundary FallbackComponent={MyFallback}>\n+              {/* Boot push + upsert device (no UI) */}\n+              <PushBootstrap />\n+\n+              {/* Navigation */}\n+              <Stack screenOptions={{ headerShown: false }} />\n+\n+              {/* Toasts globaux (respect safe-area) */}\n+              <GlobalToasts />\n+            </ErrorBoundary>\n+          </StripeProvider>\n+        </PaperProvider>\n+      </GestureHandlerRootView>\n+    </SafeAreaProvider>\n+  );\n+}\n+/* ============================================================= */\n"
        },
        {
          "date": 1758950825040,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -304,8 +304,9 @@\n     };\n   }, []); // montage unique\n \n   // B) Upsert device — réagit à user?.cep + tokens + auth\n+  const userCep = user && user.cep ? String(user.cep) : null;\n   useEffect(() => {\n     let unsubscribeAuth;\n     (async () => {\n       try {\n@@ -319,9 +320,9 @@\n             return;\n           }\n \n           // CEP depuis store, sinon fallback Firestore (1x/uid)\n-          let cep = user && user.cep ? String(user.cep) : null;\n+          let cep = userCep;\n           log('auth: CEP from store =', cep || '(none)');\n \n           if (!cep && triedFallbackForUidRef.current !== fbUser.uid) {\n             triedFallbackForUidRef.current = fbUser.uid;\n@@ -378,9 +379,9 @@\n       } catch (e) {\n         err('detach auth error:', (e && e.message) || e);\n       }\n     };\n-  }, [user && user.cep]);\n+  }, [user, userCep]);\n \n   return null;\n }\n \n@@ -415,422 +416,4 @@\n     </SafeAreaProvider>\n   );\n }\n /* ============================================================= */\n-/* =============================================================\n- VigiApp — Root layout (Push bootstrap robuste, prod-ready en dev)\n- - Android : ensure channels AVANT demande de permissions\n- - Listeners toujours détachables (fallback no-op)\n- - Ne JAMAIS couper console.error (même en release)\n- - Guards sur Firestore/CEP + masking tokens\n- - ErrorBoundary + logs horodatés\n-============================================================= */\n-\n-import { StripeProvider } from '@stripe/stripe-react-native';\n-import Constants from 'expo-constants';\n-import { Stack } from 'expo-router';\n-import React, { useEffect, useRef } from 'react';\n-import { ErrorBoundary } from 'react-error-boundary';\n-import { Text, View, Platform } from 'react-native';\n-import { GestureHandlerRootView } from 'react-native-gesture-handler';\n-import { Provider as PaperProvider } from 'react-native-paper';\n-import { SafeAreaProvider, useSafeAreaInsets } from 'react-native-safe-area-context';\n-import Toast from 'react-native-toast-message';\n-import * as Application from 'expo-application';\n-\n-import '../src/_bootstrap/monetization-init';\n-import CustomTopToast from './components/CustomTopToast';\n-\n-// 🔔 Notifications\n-import {\n-  attachNotificationListeners,\n-  getFcmDeviceTokenAsync,\n-  registerForPushNotificationsAsync,\n-  ensureAndroidChannels,\n-  initNotifications,\n-  wireAuthGateForNotifications,\n-} from '../libs/notifications';\n-\n-// Backend device upsert\n-import { upsertDevice } from '../libs/registerDevice';\n-\n-// Firebase\n-import { onAuthStateChanged } from 'firebase/auth';\n-import { doc, getDoc, getFirestore } from 'firebase/firestore';\n-import { auth } from '../firebase';\n-\n-// Store\n-import { useUserStore } from '../store/users';\n-\n-/** Fallback extra (EAS/production friendly) */\n-const extra =\n-  (Constants && Constants.expoConfig && Constants.expoConfig.extra) ||\n-  (Constants && Constants.manifestExtra) ||\n-  (Constants && Constants.manifest && Constants.manifest.extra) ||\n-  {};\n-\n-const SILENCE_RELEASE = !!extra.SILENCE_CONSOLE_IN_RELEASE;\n-const APP_TAG = 'VigiApp';\n-const LAYOUT_TAG = 'PushBootstrap';\n-\n-// Horodatage compact et safe\n-function ts() {\n-  try {\n-    return new Date().toISOString();\n-  } catch {\n-    return String(Date.now());\n-  }\n-}\n-\n-// Logger centralisé (ne coupe pas .error en prod)\n-function log(...a) {\n-  if (__DEV__ || !SILENCE_RELEASE) {\n-    try {\n-      console.log(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n-    } catch {}\n-  }\n-}\n-function warn(...a) {\n-  if (__DEV__ || !SILENCE_RELEASE) {\n-    try {\n-      console.warn(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n-    } catch {}\n-  }\n-}\n-function err(...a) {\n-  try {\n-    console.error(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n-  } catch {}\n-}\n-\n-// Polyfill Hermes (shallow clone via JSON — attention aux types non sérialisables)\n-if (typeof global.structuredClone !== 'function') {\n-  global.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));\n-  log('structuredClone polyfilled');\n-}\n-\n-// En release : on peut réduire le bruit, mais on NE coupe PAS console.error\n-if (!__DEV__ && SILENCE_RELEASE) {\n-  try {\n-    console.log = () => {};\n-  } catch {}\n-  try {\n-    console.warn = () => {};\n-  } catch {}\n-  // console.error RESTE actif\n-}\n-\n-// UI fallback de l’ErrorBoundary\n-function MyFallback({ error }) {\n-  err('ErrorBoundary caught:', error && error.message, error && error.stack);\n-  return (\n-    <View\n-      style={{\n-        flex: 1,\n-        justifyContent: 'center',\n-        alignItems: 'center',\n-        backgroundColor: '#181A20',\n-        paddingHorizontal: 24,\n-      }}\n-    >\n-      <Text style={{ color: '#FFD600', fontWeight: 'bold', fontSize: 20, marginBottom: 12 }}>\n-        Oops!\n-      </Text>\n-      <Text style={{ color: '#fff', textAlign: 'center', fontSize: 16, marginBottom: 8 }}>\n-        {(error && error.message) || 'Une erreur est survenue.'}\n-      </Text>\n-      <Text style={{ color: '#aaa', fontSize: 12, textAlign: 'center' }}>\n-        Essaie de relancer l’application.\n-      </Text>\n-    </View>\n-  );\n-}\n-\n-function mapSeverityToToastType(sev) {\n-  const s = String(sev || '').toLowerCase();\n-  if (s === 'high' || s === 'grave') {return 'error';}\n-  if (s === 'low' || s === 'minor') {return 'success';}\n-  return 'info';\n-}\n-\n-// Firestore: récup CEP au besoin (fallback unique par uid)\n-async function fetchUserCepFromFirestore(uid) {\n-  try {\n-    const db = getFirestore();\n-    const ref = doc(db, 'users', uid);\n-    const snap = await getDoc(ref);\n-    const cep = snap.exists() ? snap.data() && (snap.data().cep ?? null) : null;\n-    log('[fallback] Firestore CEP =', cep || '(none)');\n-    return cep ? String(cep) : null;\n-  } catch (e) {\n-    warn('[fallback] Firestore CEP error:', (e && e.message) || e);\n-    return null;\n-  }\n-}\n-\n-// Utils logs\n-function safeJson(obj) {\n-  try {\n-    return JSON.stringify(obj).slice(0, 1000);\n-  } catch {\n-    return '[unserializable]';\n-  }\n-}\n-function maskToken(tok) {\n-  if (!tok) {return tok;}\n-  const s = String(tok);\n-  return s.length <= 12 ? s : `${s.slice(0, 12)}…(${s.length})`;\n-}\n-\n-/** Toast global tenant compte du safe-area top */\n-function GlobalToasts() {\n-  const insets = useSafeAreaInsets();\n-  return (\n-    <Toast\n-      config={{\n-        success: (props) => <CustomTopToast {...props} />,\n-        info: (props) => <CustomTopToast {...props} />,\n-        error: (props) => <CustomTopToast {...props} />,\n-        default: (props) => <CustomTopToast {...props} />,\n-      }}\n-      position=\"top\"\n-      topOffset={Math.max(10, insets.top)}\n-    />\n-  );\n-}\n-\n-// Composant “headless” qui fait tout le bootstrap notifs + upsert device\n-function PushBootstrap() {\n-  const expoTokenRef = useRef(null);\n-  const fcmTokenRef = useRef(null);\n-  const lastUpsertKeyRef = useRef('');\n-  const triedFallbackForUidRef = useRef(''); // évite Firestore fallback multiple\n-  const { user } = useUserStore();\n-\n-  // A) Infra notifications + listeners — une seule fois au montage\n-  useEffect(() => {\n-    let detachListeners = () => {};\n-    (async () => {\n-      const t0 = Date.now();\n-      log('mount → start bootstrap');\n-\n-      // 🔐 Lie notifs ↔ auth (navigation après tap notif quand app fermée)\n-      try {\n-        wireAuthGateForNotifications(auth);\n-      } catch (e) {\n-        warn('wireAuthGateForNotifications error:', (e && e.message) || e);\n-      }\n-\n-      // Android : canaux D’ABORD, puis init (perms, cold start)\n-      try {\n-        await ensureAndroidChannels();\n-      } catch (e) {\n-        warn('ensureAndroidChannels error:', (e && e.message) || e);\n-      }\n-\n-      try {\n-        await initNotifications();\n-        log('initNotifications ok');\n-      } catch (e) {\n-        warn('initNotifications error:', (e && e.message) || e);\n-      }\n-\n-      // a) Listeners\n-      try {\n-        const maybeDetach = attachNotificationListeners({\n-          onReceive: (n) => {\n-            const content = (n && n.request && n.request.content) || {};\n-            const title = content.title || 'VigiApp';\n-            const body = content.body || '';\n-            const sev =\n-              (content.data && (content.data.severidade || content.data.severity)) || undefined;\n-            const type = mapSeverityToToastType(sev);\n-            const line = body ? `${title} — ${body}` : title;\n-            const imageUrl =\n-              (content.data && (content.data.image || content.data.imageUrl)) ||\n-              content.image ||\n-              content.imageUrl ||\n-              null;\n-\n-            log('listener:onReceive', safeJson({ title, data: content.data }));\n-            Toast.show({\n-              type,\n-              text1: line,\n-              position: 'top',\n-              visibilityTime: 8000,\n-              autoHide: true,\n-              props: { imageUrl },\n-            });\n-          },\n-          onResponse: (r) => {\n-            const data =\n-              r &&\n-              r.notification &&\n-              r.notification.request &&\n-              r.notification.request.content &&\n-              r.notification.request.content.data;\n-            log('listener:onResponse', safeJson({ data }));\n-          },\n-        });\n-        detachListeners = typeof maybeDetach === 'function' ? maybeDetach : () => {};\n-        log('listeners attached');\n-      } catch (e) {\n-        err('attachNotificationListeners failed:', (e && e.message) || e);\n-      }\n-\n-      // b) Permissions + Expo push token\n-      try {\n-        const expoTok = await registerForPushNotificationsAsync();\n-        expoTokenRef.current = expoTok || null;\n-        log('expo token obtained:', maskToken(expoTok));\n-      } catch (e) {\n-        warn('registerForPushNotificationsAsync error:', (e && e.message) || e);\n-      }\n-\n-      // c) FCM device token (peut arriver en retard)\n-      try {\n-        let fcmTok = await getFcmDeviceTokenAsync();\n-        fcmTokenRef.current = fcmTok || null;\n-        log('fcm token obtained:', maskToken(fcmTok));\n-        if (!fcmTok) {\n-          setTimeout(async () => {\n-            try {\n-              const retry = await getFcmDeviceTokenAsync();\n-              if (retry) {\n-                fcmTokenRef.current = retry;\n-                log('fcm token late obtained:', maskToken(retry));\n-              }\n-            } catch {}\n-          }, 2500);\n-        }\n-      } catch (e) {\n-        warn('getFcmDeviceTokenAsync error:', (e && e.message) || e);\n-      }\n-\n-      const dt = Date.now() - t0;\n-      log('bootstrap completed in', `${dt}ms`);\n-    })();\n-\n-    // Cleanup strict-mode safe\n-    return () => {\n-      log('unmount → cleanup…');\n-      try {\n-        detachListeners && detachListeners();\n-        log('listeners detached');\n-      } catch (e) {\n-        err('detach listeners error:', (e && e.message) || e);\n-      }\n-    };\n-  }, []); // montage unique\n-\n-  // B) Upsert device — réagit à user?.cep + tokens + auth\n-  useEffect(() => {\n-    let unsubscribeAuth;\n-    (async () => {\n-      try {\n-        const unsub = onAuthStateChanged(auth, async (fbUser) => {\n-          if (!fbUser) {\n-            log('auth: signed out (no upsert)');\n-            return;\n-          }\n-          if (!expoTokenRef.current && !fcmTokenRef.current) {\n-            warn('auth: user present but no tokens yet (will upsert later)');\n-            return;\n-          }\n-\n-          // CEP depuis store, sinon fallback Firestore (1x/uid)\n-          let cep = user && user.cep ? String(user.cep) : null;\n-          log('auth: CEP from store =', cep || '(none)');\n-\n-          if (!cep && triedFallbackForUidRef.current !== fbUser.uid) {\n-            triedFallbackForUidRef.current = fbUser.uid;\n-            cep = await fetchUserCepFromFirestore(fbUser.uid);\n-          }\n-          if (!cep) {\n-            warn('auth: CEP missing → skip device upsert');\n-            return;\n-          }\n-\n-          // Idempotence via clé (uid + prefixes tokens)\n-          const key = `${fbUser.uid}:${String(expoTokenRef.current || '').slice(0, 12)}:${String(\n-            fcmTokenRef.current || '',\n-          ).slice(0, 12)}`;\n-          if (lastUpsertKeyRef.current === key) {\n-            log('auth: upsert skipped (same uid+tokens prefix)', key);\n-            return;\n-          }\n-\n-          log('auth: signed in → upsert device…', { uid: fbUser.uid, key, cep });\n-          try {\n-            const res = await upsertDevice({\n-              userId: fbUser.uid,\n-              expoPushToken: expoTokenRef.current,\n-              fcmDeviceToken: fcmTokenRef.current,\n-              cep,\n-              appVersion:\n-                Application.nativeApplicationVersion ||\n-                (await Application.getApplicationVersionAsync()) ||\n-                '0',\n-              platform: Platform.OS,\n-            });\n-            if (res && res.ok) {\n-              log('upsert success:', (res && res.id) || '(no id)');\n-              lastUpsertKeyRef.current = key;\n-            } else {\n-              warn('upsert returned not ok:', (res && res.error) || 'unknown');\n-            }\n-          } catch (e) {\n-            err('upsert failed:', (e && e.message) || e);\n-          }\n-        });\n-        unsubscribeAuth = typeof unsub === 'function' ? unsub : undefined;\n-        log('auth listener attached (upsert)');\n-      } catch (e) {\n-        err('attach onAuthStateChanged failed (upsert effect):', (e && e.message) || e);\n-      }\n-    })();\n-\n-    return () => {\n-      try {\n-        unsubscribeAuth && unsubscribeAuth();\n-        log('auth listener detached (upsert)');\n-      } catch (e) {\n-        err('detach auth error:', (e && e.message) || e);\n-      }\n-    };\n-  }, [user && user.cep]);\n-\n-  return null;\n-}\n-\n-export default function Layout() {\n-  const publishableKey = String(extra.STRIPE_PUBLISHABLE_KEY || '');\n-  if (!publishableKey) {\n-    warn('Stripe publishableKey is empty in extra.STRIPE_PUBLISHABLE_KEY');\n-  } else {\n-    log('Stripe key present (masked len):', `${String(publishableKey).length} chars`);\n-  }\n-\n-  log('Layout render');\n-\n-  return (\n-    <SafeAreaProvider>\n-      <GestureHandlerRootView style={{ flex: 1 }}>\n-        <PaperProvider>\n-          <StripeProvider publishableKey={publishableKey}>\n-            <ErrorBoundary FallbackComponent={MyFallback}>\n-              {/* Boot push + upsert device (no UI) */}\n-              <PushBootstrap />\n-\n-              {/* Navigation */}\n-              <Stack screenOptions={{ headerShown: false }} />\n-\n-              {/* Toasts globaux (respect safe-area) */}\n-              <GlobalToasts />\n-            </ErrorBoundary>\n-          </StripeProvider>\n-        </PaperProvider>\n-      </GestureHandlerRootView>\n-    </SafeAreaProvider>\n-  );\n-}\n-/* ============================================================= */\n"
        },
        {
          "date": 1758950837999,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,9 +350,9 @@\n               fcmDeviceToken: fcmTokenRef.current,\n               cep,\n               appVersion:\n                 Application.nativeApplicationVersion ||\n-                (await Application.getApplicationNameAsync()) ||\n+                Application.applicationName ||\n                 '0',\n               platform: Platform.OS,\n             });\n             if (res && res.ok) {\n"
        }
      ],
      "date": 1758950164997,
      "name": "Commit-0",
      "content": "/* =============================================================\n VigiApp — Root layout (Push bootstrap robuste, prod-ready en dev)\n - Android : ensure channels AVANT demande de permissions\n - Listeners toujours détachables (fallback no-op)\n - Ne JAMAIS couper console.error (même en release)\n - Guards sur Firestore/CEP + masking tokens\n - ErrorBoundary + logs horodatés\n============================================================= */\n\nimport { StripeProvider } from \"@stripe/stripe-react-native\";\nimport Constants from \"expo-constants\";\nimport { Stack } from \"expo-router\";\nimport React, { useEffect, useRef } from \"react\";\nimport { ErrorBoundary } from \"react-error-boundary\";\nimport { Text, View, Platform } from \"react-native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { Provider as PaperProvider } from \"react-native-paper\";\nimport { SafeAreaProvider, useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport Toast from \"react-native-toast-message\";\nimport * as Application from \"expo-application\";\n\nimport \"../src/_bootstrap/monetization-init\";\nimport CustomTopToast from \"./components/CustomTopToast\";\n\n// 🔔 Notifications\nimport {\n  attachNotificationListeners,\n  getFcmDeviceTokenAsync,\n  registerForPushNotificationsAsync,\n  ensureAndroidChannels,\n  initNotifications,\n  wireAuthGateForNotifications,\n} from \"../libs/notifications\";\n\n// Backend device upsert\nimport { upsertDevice } from \"../libs/registerDevice\";\n\n// Firebase\nimport { onAuthStateChanged } from \"firebase/auth\";\nimport { doc, getDoc, getFirestore } from \"firebase/firestore\";\nimport { auth } from \"../firebase\";\n\n// Store\nimport { useUserStore } from \"../store/users\";\n\n/** Fallback extra (EAS/production friendly) */\nconst extra =\n  (Constants && Constants.expoConfig && Constants.expoConfig.extra) ||\n  (Constants && Constants.manifestExtra) ||\n  (Constants && Constants.manifest && Constants.manifest.extra) ||\n  {};\n\nconst SILENCE_RELEASE = !!extra.SILENCE_CONSOLE_IN_RELEASE;\nconst APP_TAG = \"VigiApp\";\nconst LAYOUT_TAG = \"PushBootstrap\";\n\n// Horodatage compact et safe\nfunction ts() {\n  try {\n    return new Date().toISOString();\n  } catch {\n    return String(Date.now());\n  }\n}\n\n// Logger centralisé (ne coupe pas .error en prod)\nfunction log(...a) {\n  if (__DEV__ || !SILENCE_RELEASE) {\n    try {\n      console.log(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n    } catch {}\n  }\n}\nfunction warn(...a) {\n  if (__DEV__ || !SILENCE_RELEASE) {\n    try {\n      console.warn(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n    } catch {}\n  }\n}\nfunction err(...a) {\n  try {\n    console.error(`[${APP_TAG}][${LAYOUT_TAG}][${ts()}]`, ...a);\n  } catch {}\n}\n\n// Polyfill Hermes (shallow clone via JSON — attention aux types non sérialisables)\nif (typeof global.structuredClone !== \"function\") {\n  global.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));\n  log(\"structuredClone polyfilled\");\n}\n\n// En release : on peut réduire le bruit, mais on NE coupe PAS console.error\nif (!__DEV__ && SILENCE_RELEASE) {\n  try {\n    console.log = () => {};\n  } catch {}\n  try {\n    console.warn = () => {};\n  } catch {}\n  // console.error RESTE actif\n}\n\n// UI fallback de l’ErrorBoundary\nfunction MyFallback({ error }) {\n  err(\"ErrorBoundary caught:\", error && error.message, error && error.stack);\n  return (\n    <View\n      style={{\n        flex: 1,\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        backgroundColor: \"#181A20\",\n        paddingHorizontal: 24,\n      }}\n    >\n      <Text style={{ color: \"#FFD600\", fontWeight: \"bold\", fontSize: 20, marginBottom: 12 }}>\n        Oops!\n      </Text>\n      <Text style={{ color: \"#fff\", textAlign: \"center\", fontSize: 16, marginBottom: 8 }}>\n        {(error && error.message) || \"Une erreur est survenue.\"}\n      </Text>\n      <Text style={{ color: \"#aaa\", fontSize: 12, textAlign: \"center\" }}>\n        Essaie de relancer l’application.\n      </Text>\n    </View>\n  );\n}\n\nfunction mapSeverityToToastType(sev) {\n  const s = String(sev || \"\").toLowerCase();\n  if (s === \"high\" || s === \"grave\") return \"error\";\n  if (s === \"low\" || s === \"minor\") return \"success\";\n  return \"info\";\n}\n\n// Firestore: récup CEP au besoin (fallback unique par uid)\nasync function fetchUserCepFromFirestore(uid) {\n  try {\n    const db = getFirestore();\n    const ref = doc(db, \"users\", uid);\n    const snap = await getDoc(ref);\n    const cep = snap.exists() ? (snap.data() && (snap.data().cep ?? null)) : null;\n    log(\"[fallback] Firestore CEP =\", cep || \"(none)\");\n    return cep ? String(cep) : null;\n  } catch (e) {\n    warn(\"[fallback] Firestore CEP error:\", (e && e.message) || e);\n    return null;\n  }\n}\n\n// Utils logs\nfunction safeJson(obj) {\n  try {\n    return JSON.stringify(obj).slice(0, 1000);\n  } catch {\n    return \"[unserializable]\";\n  }\n}\nfunction maskToken(tok) {\n  if (!tok) return tok;\n  const s = String(tok);\n  return s.length <= 12 ? s : `${s.slice(0, 12)}…(${s.length})`;\n}\n\n/** Toast global tenant compte du safe-area top */\nfunction GlobalToasts() {\n  const insets = useSafeAreaInsets();\n  return (\n    <Toast\n      config={{\n        success: (props) => <CustomTopToast {...props} />,\n        info: (props) => <CustomTopToast {...props} />,\n        error: (props) => <CustomTopToast {...props} />,\n        default: (props) => <CustomTopToast {...props} />,\n      }}\n      position=\"top\"\n      topOffset={Math.max(10, insets.top)}\n    />\n  );\n}\n\n// Composant “headless” qui fait tout le bootstrap notifs + upsert device\nfunction PushBootstrap() {\n  const expoTokenRef = useRef(null);\n  const fcmTokenRef = useRef(null);\n  const lastUpsertKeyRef = useRef(\"\");\n  const triedFallbackForUidRef = useRef(\"\"); // évite Firestore fallback multiple\n  const { user } = useUserStore();\n\n  // A) Infra notifications + listeners — une seule fois au montage\n  useEffect(() => {\n    let detachListeners = () => {};\n    (async () => {\n      const t0 = Date.now();\n      log(\"mount → start bootstrap\");\n\n      // 🔐 Lie notifs ↔ auth (navigation après tap notif quand app fermée)\n      try {\n        wireAuthGateForNotifications(auth);\n      } catch (e) {\n        warn(\"wireAuthGateForNotifications error:\", (e && e.message) || e);\n      }\n\n      // Android : canaux D’ABORD, puis init (perms, cold start)\n      try {\n        await ensureAndroidChannels();\n      } catch (e) {\n        warn(\"ensureAndroidChannels error:\", (e && e.message) || e);\n      }\n\n      try {\n        await initNotifications();\n        log(\"initNotifications ok\");\n      } catch (e) {\n        warn(\"initNotifications error:\", (e && e.message) || e);\n      }\n\n      // a) Listeners\n      try {\n        const maybeDetach = attachNotificationListeners({\n          onReceive: (n) => {\n            const content = (n && n.request && n.request.content) || {};\n            const title = content.title || \"VigiApp\";\n            const body = content.body || \"\";\n            const sev =\n              (content.data && (content.data.severidade || content.data.severity)) || undefined;\n            const type = mapSeverityToToastType(sev);\n            const line = body ? `${title} — ${body}` : title;\n            const imageUrl =\n              (content.data && (content.data.image || content.data.imageUrl)) ||\n              content.image ||\n              content.imageUrl ||\n              null;\n\n            log(\"listener:onReceive\", safeJson({ title, data: content.data }));\n            Toast.show({\n              type,\n              text1: line,\n              position: \"top\",\n              visibilityTime: 8000,\n              autoHide: true,\n              props: { imageUrl },\n            });\n          },\n          onResponse: (r) => {\n            const data =\n              r &&\n              r.notification &&\n              r.notification.request &&\n              r.notification.request.content &&\n              r.notification.request.content.data;\n            log(\"listener:onResponse\", safeJson({ data }));\n          },\n        });\n        detachListeners = typeof maybeDetach === \"function\" ? maybeDetach : () => {};\n        log(\"listeners attached\");\n      } catch (e) {\n        err(\"attachNotificationListeners failed:\", (e && e.message) || e);\n      }\n\n      // b) Permissions + Expo push token\n      try {\n        const expoTok = await registerForPushNotificationsAsync();\n        expoTokenRef.current = expoTok || null;\n        log(\"expo token obtained:\", maskToken(expoTok));\n      } catch (e) {\n        warn(\"registerForPushNotificationsAsync error:\", (e && e.message) || e);\n      }\n\n      // c) FCM device token (peut arriver en retard)\n      try {\n        let fcmTok = await getFcmDeviceTokenAsync();\n        fcmTokenRef.current = fcmTok || null;\n        log(\"fcm token obtained:\", maskToken(fcmTok));\n        if (!fcmTok) {\n          setTimeout(async () => {\n            try {\n              const retry = await getFcmDeviceTokenAsync();\n              if (retry) {\n                fcmTokenRef.current = retry;\n                log(\"fcm token late obtained:\", maskToken(retry));\n              }\n            } catch {}\n          }, 2500);\n        }\n      } catch (e) {\n        warn(\"getFcmDeviceTokenAsync error:\", (e && e.message) || e);\n      }\n\n      const dt = Date.now() - t0;\n      log(\"bootstrap completed in\", `${dt}ms`);\n    })();\n\n    // Cleanup strict-mode safe\n    return () => {\n      log(\"unmount → cleanup…\");\n      try {\n        detachListeners && detachListeners();\n        log(\"listeners detached\");\n      } catch (e) {\n        err(\"detach listeners error:\", (e && e.message) || e);\n      }\n    };\n  }, []); // montage unique\n\n  // B) Upsert device — réagit à user?.cep + tokens + auth\n  useEffect(() => {\n    let unsubscribeAuth;\n    (async () => {\n      try {\n        const unsub = onAuthStateChanged(auth, async (fbUser) => {\n          if (!fbUser) {\n            log(\"auth: signed out (no upsert)\");\n            return;\n          }\n          if (!expoTokenRef.current && !fcmTokenRef.current) {\n            warn(\"auth: user present but no tokens yet (will upsert later)\");\n            return;\n          }\n\n          // CEP depuis store, sinon fallback Firestore (1x/uid)\n          let cep = user && user.cep ? String(user.cep) : null;\n          log(\"auth: CEP from store =\", cep || \"(none)\");\n\n          if (!cep && triedFallbackForUidRef.current !== fbUser.uid) {\n            triedFallbackForUidRef.current = fbUser.uid;\n            cep = await fetchUserCepFromFirestore(fbUser.uid);\n          }\n          if (!cep) {\n            warn(\"auth: CEP missing → skip device upsert\");\n            return;\n          }\n\n          // Idempotence via clé (uid + prefixes tokens)\n          const key = `${fbUser.uid}:${String(expoTokenRef.current || \"\").slice(0, 12)}:${String(\n            fcmTokenRef.current || \"\"\n          ).slice(0, 12)}`;\n          if (lastUpsertKeyRef.current === key) {\n            log(\"auth: upsert skipped (same uid+tokens prefix)\", key);\n            return;\n          }\n\n          log(\"auth: signed in → upsert device…\", { uid: fbUser.uid, key, cep });\n          try {\n            const res = await upsertDevice({\n              userId: fbUser.uid,\n              expoPushToken: expoTokenRef.current,\n              fcmDeviceToken: fcmTokenRef.current,\n              cep,\n              appVersion:\n                Application.nativeApplicationVersion ||\n                Application.applicationVersion ||\n                \"0\",\n              platform: Platform.OS,\n            });\n            if (res && res.ok) {\n              log(\"upsert success:\", (res && res.id) || \"(no id)\");\n              lastUpsertKeyRef.current = key;\n            } else {\n              warn(\"upsert returned not ok:\", (res && res.error) || \"unknown\");\n            }\n          } catch (e) {\n            err(\"upsert failed:\", (e && e.message) || e);\n          }\n        });\n        unsubscribeAuth = typeof unsub === \"function\" ? unsub : undefined;\n        log(\"auth listener attached (upsert)\");\n      } catch (e) {\n        err(\"attach onAuthStateChanged failed (upsert effect):\", (e && e.message) || e);\n      }\n    })();\n\n    return () => {\n      try {\n        unsubscribeAuth && unsubscribeAuth();\n        log(\"auth listener detached (upsert)\");\n      } catch (e) {\n        err(\"detach auth error:\", (e && e.message) || e);\n      }\n    };\n  }, [user && user.cep]);\n\n  return null;\n}\n\nexport default function Layout() {\n  const publishableKey = String(extra.STRIPE_PUBLISHABLE_KEY || \"\");\n  if (!publishableKey) {\n    warn(\"Stripe publishableKey is empty in extra.STRIPE_PUBLISHABLE_KEY\");\n  } else {\n    log(\"Stripe key present (masked len):\", `${String(publishableKey).length} chars`);\n  }\n\n  log(\"Layout render\");\n\n  return (\n    <SafeAreaProvider>\n      <GestureHandlerRootView style={{ flex: 1 }}>\n        <PaperProvider>\n          <StripeProvider publishableKey={publishableKey}>\n            <ErrorBoundary FallbackComponent={MyFallback}>\n              {/* Boot push + upsert device (no UI) */}\n              <PushBootstrap />\n\n              {/* Navigation */}\n              <Stack screenOptions={{ headerShown: false }} />\n\n              {/* Toasts globaux (respect safe-area) */}\n              <GlobalToasts />\n            </ErrorBoundary>\n          </StripeProvider>\n        </PaperProvider>\n      </GestureHandlerRootView>\n    </SafeAreaProvider>\n  );\n}\n/* ============================================================= */\n"
    }
  ]
}
