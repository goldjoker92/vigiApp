{
  "sourceFile": "server/routes/login.js",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 6,
      "patches": [
        {
          "date": 1758952294613,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        },
        {
          "date": 1758952306684,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n     if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n       // nouveau client déjà branché\n       effectivePrehash = prehash;\n-      effectiveSaltId = saltId;\n+      // effectiveSaltId = saltId; // Removed unused variable assignment\n     } else if (typeof password === 'string') {\n       // ancien client : on calcule le pré-hash serveur-side (fallback)\n       effectivePrehash = sha256HexServerPrefixed(password);\n     } else {\n"
        },
        {
          "date": 1758952329054,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,88 @@\n+/**\n+ * server/routes/login.js\n+ * Routes /signup et /login.\n+ * - Accepte { prehash, saltId } (nouveau client)\n+ * - OU { password } (ancien client) : on pré-hash côté serveur pour compat\n+ *\n+ * NOTE: Remplace la Map \"users\" par ton DB (mongodb, pg, etc.) en prod.\n+ */\n+import express from 'express';\n+import crypto from 'node:crypto';\n+import { HASH_SCHEMES } from '../securityConfig.js';\n+import { hashForStorageFromClientPrehash, verifyFromClientPrehash } from '../passwordService.js';\n+\n+const router = express.Router();\n+// Map en mémoire pour tests rapides (email -> { storedHash, perUserSalt, hashVersion })\n+const users = new Map();\n+\n+/** utilitaire : sha256 hex avec prefix \"v1::\" identique au client */\n+function sha256HexServerPrefixed(plain) {\n+  const buf = crypto\n+    .createHash('sha256')\n+    .update('v1::' + plain, 'utf8')\n+    .digest();\n+  return Array.from(buf)\n+    .map((b) => b.toString(16).padStart(2, '0'))\n+    .join('');\n+}\n+\n+/** Signup lit { email, prehash, saltId } (nouveau flow) */\n+router.post('/signup', async (req, res) => {\n+  try {\n+    const { email, prehash, saltId } = req.body ?? {};\n+    if (!email || !prehash || !saltId)\n+      {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n+    if (!Object.hasOwn(HASH_SCHEMES, saltId))\n+      {return res.status(400).json({ ok: false, code: 'UNSUPPORTED_SALT_ID' });}\n+    if (users.has(email)) {return res.status(409).json({ ok: false, code: 'ALREADY_EXISTS' });}\n+\n+    const rec = await hashForStorageFromClientPrehash(prehash, saltId);\n+    users.set(email, rec);\n+    return res.json({ ok: true });\n+  } catch (e) {\n+    console.error(e);\n+    return res.status(500).json({ ok: false });\n+  }\n+});\n+\n+/** Login : accepte ancien et nouveau format */\n+router.post('/login', async (req, res) => {\n+  try {\n+    const { email, prehash, saltId, password } = req.body ?? {};\n+    if (!email) {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n+\n+    let effectivePrehash, effectiveSaltId;\n+\n+    if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n+      // nouveau client déjà branché\n+      effectivePrehash = prehash;\n+       effectiveSaltId = saltId; // Removed unused variable assignment\n+    } else if (typeof password === 'string') {\n+      // ancien client : on calcule le pré-hash serveur-side (fallback)\n+      effectivePrehash = sha256HexServerPrefixed(password);\n+    } else {\n+      return res.status(400).json({ ok: false, code: 'MISSING_CREDENTIALS' });\n+    }\n+\n+    // récupère l'utilisateur (ici Map, remplace par DB en prod)\n+    const user = users.get(email);\n+    if (!user) {return res.status(401).json({ ok: false });}\n+\n+    // vérification avec passwordService\n+    const ok = await verifyFromClientPrehash(effectivePrehash, {\n+      storedHash: user.storedHash,\n+      perUserSalt: user.perUserSalt,\n+      hashVersion: user.hashVersion,\n+    });\n+\n+    if (!ok) {return res.status(401).json({ ok: false });}\n+\n+    // succès : génère token réel ici (JWT) ; renvoi fake pour test\n+    return res.json({ ok: true, token: 'FAKE_JWT_FOR_TEST' });\n+  } catch (e) {\n+    console.error(e);\n+    return res.status(500).json({ ok: false });\n+  }\n+});\n+\n+export default router;\n"
        },
        {
          "date": 1758952343044,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n     if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n       // nouveau client déjà branché\n       effectivePrehash = prehash;\n-       effectiveSaltId = saltId; // Removed unused variable assignment\n+       effectiveSaltId = saltId; \n     } else if (typeof password === 'string') {\n       // ancien client : on calcule le pré-hash serveur-side (fallback)\n       effectivePrehash = sha256HexServerPrefixed(password);\n     } else {\n@@ -85,92 +85,4 @@\n   }\n });\n \n export default router;\n-/**\n- * server/routes/login.js\n- * Routes /signup et /login.\n- * - Accepte { prehash, saltId } (nouveau client)\n- * - OU { password } (ancien client) : on pré-hash côté serveur pour compat\n- *\n- * NOTE: Remplace la Map \"users\" par ton DB (mongodb, pg, etc.) en prod.\n- */\n-import express from 'express';\n-import crypto from 'node:crypto';\n-import { HASH_SCHEMES } from '../securityConfig.js';\n-import { hashForStorageFromClientPrehash, verifyFromClientPrehash } from '../passwordService.js';\n-\n-const router = express.Router();\n-// Map en mémoire pour tests rapides (email -> { storedHash, perUserSalt, hashVersion })\n-const users = new Map();\n-\n-/** utilitaire : sha256 hex avec prefix \"v1::\" identique au client */\n-function sha256HexServerPrefixed(plain) {\n-  const buf = crypto\n-    .createHash('sha256')\n-    .update('v1::' + plain, 'utf8')\n-    .digest();\n-  return Array.from(buf)\n-    .map((b) => b.toString(16).padStart(2, '0'))\n-    .join('');\n-}\n-\n-/** Signup lit { email, prehash, saltId } (nouveau flow) */\n-router.post('/signup', async (req, res) => {\n-  try {\n-    const { email, prehash, saltId } = req.body ?? {};\n-    if (!email || !prehash || !saltId)\n-      {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n-    if (!Object.hasOwn(HASH_SCHEMES, saltId))\n-      {return res.status(400).json({ ok: false, code: 'UNSUPPORTED_SALT_ID' });}\n-    if (users.has(email)) {return res.status(409).json({ ok: false, code: 'ALREADY_EXISTS' });}\n-\n-    const rec = await hashForStorageFromClientPrehash(prehash, saltId);\n-    users.set(email, rec);\n-    return res.json({ ok: true });\n-  } catch (e) {\n-    console.error(e);\n-    return res.status(500).json({ ok: false });\n-  }\n-});\n-\n-/** Login : accepte ancien et nouveau format */\n-router.post('/login', async (req, res) => {\n-  try {\n-    const { email, prehash, saltId, password } = req.body ?? {};\n-    if (!email) {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n-\n-    let effectivePrehash, effectiveSaltId;\n-\n-    if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n-      // nouveau client déjà branché\n-      effectivePrehash = prehash;\n-      // effectiveSaltId = saltId; // Removed unused variable assignment\n-    } else if (typeof password === 'string') {\n-      // ancien client : on calcule le pré-hash serveur-side (fallback)\n-      effectivePrehash = sha256HexServerPrefixed(password);\n-    } else {\n-      return res.status(400).json({ ok: false, code: 'MISSING_CREDENTIALS' });\n-    }\n-\n-    // récupère l'utilisateur (ici Map, remplace par DB en prod)\n-    const user = users.get(email);\n-    if (!user) {return res.status(401).json({ ok: false });}\n-\n-    // vérification avec passwordService\n-    const ok = await verifyFromClientPrehash(effectivePrehash, {\n-      storedHash: user.storedHash,\n-      perUserSalt: user.perUserSalt,\n-      hashVersion: user.hashVersion,\n-    });\n-\n-    if (!ok) {return res.status(401).json({ ok: false });}\n-\n-    // succès : génère token réel ici (JWT) ; renvoi fake pour test\n-    return res.json({ ok: true, token: 'FAKE_JWT_FOR_TEST' });\n-  } catch (e) {\n-    console.error(e);\n-    return res.status(500).json({ ok: false });\n-  }\n-});\n-\n-export default router;\n"
        },
        {
          "date": 1758952351732,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n     if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n       // nouveau client déjà branché\n       effectivePrehash = prehash;\n-       effectiveSaltId = saltId; \n+      // effectiveSaltId is not used, so we remove its assignment\n     } else if (typeof password === 'string') {\n       // ancien client : on calcule le pré-hash serveur-side (fallback)\n       effectivePrehash = sha256HexServerPrefixed(password);\n     } else {\n"
        },
        {
          "date": 1758952359128,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n     if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n       // nouveau client déjà branché\n       effectivePrehash = prehash;\n-      // effectiveSaltId is not used, so we remove its assignment\n+      // effectiveSaltId is n\n     } else if (typeof password === 'string') {\n       // ancien client : on calcule le pré-hash serveur-side (fallback)\n       effectivePrehash = sha256HexServerPrefixed(password);\n     } else {\n"
        },
        {
          "date": 1758952377437,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n     if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n       // nouveau client déjà branché\n       effectivePrehash = prehash;\n-      // effectiveSaltId is\n+      // effectiveSaltId is not used, so we remove its assignment\n     } else if (typeof password === 'string') {\n       // ancien client : on calcule le pré-hash serveur-side (fallback)\n       effectivePrehash = sha256HexServerPrefixed(password);\n     } else {\n"
        }
      ],
      "date": 1758952294612,
      "name": "Commit-0",
      "content": "/**\n * server/routes/login.js\n * Routes /signup et /login.\n * - Accepte { prehash, saltId } (nouveau client)\n * - OU { password } (ancien client) : on pré-hash côté serveur pour compat\n *\n * NOTE: Remplace la Map \"users\" par ton DB (mongodb, pg, etc.) en prod.\n */\nimport express from 'express';\nimport crypto from 'node:crypto';\nimport { HASH_SCHEMES } from '../securityConfig.js';\nimport { hashForStorageFromClientPrehash, verifyFromClientPrehash } from '../passwordService.js';\n\nconst router = express.Router();\n// Map en mémoire pour tests rapides (email -> { storedHash, perUserSalt, hashVersion })\nconst users = new Map();\n\n/** utilitaire : sha256 hex avec prefix \"v1::\" identique au client */\nfunction sha256HexServerPrefixed(plain) {\n  const buf = crypto\n    .createHash('sha256')\n    .update('v1::' + plain, 'utf8')\n    .digest();\n  return Array.from(buf)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/** Signup lit { email, prehash, saltId } (nouveau flow) */\nrouter.post('/signup', async (req, res) => {\n  try {\n    const { email, prehash, saltId } = req.body ?? {};\n    if (!email || !prehash || !saltId)\n      {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n    if (!Object.hasOwn(HASH_SCHEMES, saltId))\n      {return res.status(400).json({ ok: false, code: 'UNSUPPORTED_SALT_ID' });}\n    if (users.has(email)) {return res.status(409).json({ ok: false, code: 'ALREADY_EXISTS' });}\n\n    const rec = await hashForStorageFromClientPrehash(prehash, saltId);\n    users.set(email, rec);\n    return res.json({ ok: true });\n  } catch (e) {\n    console.error(e);\n    return res.status(500).json({ ok: false });\n  }\n});\n\n/** Login : accepte ancien et nouveau format */\nrouter.post('/login', async (req, res) => {\n  try {\n    const { email, prehash, saltId, password } = req.body ?? {};\n    if (!email) {return res.status(400).json({ ok: false, code: 'BAD_REQUEST' });}\n\n    let effectivePrehash, effectiveSaltId;\n\n    if (prehash && saltId && Object.hasOwn(HASH_SCHEMES, saltId)) {\n      // nouveau client déjà branché\n      effectivePrehash = prehash;\n      effectiveSaltId = saltId;\n    } else if (typeof password === 'string') {\n      // ancien client : on calcule le pré-hash serveur-side (fallback)\n      effectivePrehash = sha256HexServerPrefixed(password);\n    } else {\n      return res.status(400).json({ ok: false, code: 'MISSING_CREDENTIALS' });\n    }\n\n    // récupère l'utilisateur (ici Map, remplace par DB en prod)\n    const user = users.get(email);\n    if (!user) {return res.status(401).json({ ok: false });}\n\n    // vérification avec passwordService\n    const ok = await verifyFromClientPrehash(effectivePrehash, {\n      storedHash: user.storedHash,\n      perUserSalt: user.perUserSalt,\n      hashVersion: user.hashVersion,\n    });\n\n    if (!ok) {return res.status(401).json({ ok: false });}\n\n    // succès : génère token réel ici (JWT) ; renvoi fake pour test\n    return res.json({ ok: true, token: 'FAKE_JWT_FOR_TEST' });\n  } catch (e) {\n    console.error(e);\n    return res.status(500).json({ ok: false });\n  }\n});\n\nexport default router;\n"
    }
  ]
}
