{
  "sourceFile": "client/authCliRT.js",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1758954348883,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1758954348883,
      "name": "Commit-0",
      "content": "import fs from 'fs';\nimport path from 'path';\nimport { Buffer } from 'buffer';\n\nconst API_KEY = process.env.FB_API_KEY || 'REPLACE_ME';\nconst SESSION_PATH = path.resolve('./client/.session.json');\n\nfunction readSession() {\n  try {\n    return JSON.parse(fs.readFileSync(SESSION_PATH, 'utf8'));\n  } catch {\n    return null;\n  }\n}\nfunction writeSession(s) {\n  fs.writeFileSync(SESSION_PATH, JSON.stringify(s, null, 2), 'utf8');\n}\nfunction deleteSession() {\n  try {\n    fs.unlinkSync(SESSION_PATH);\n  } catch {}\n}\nfunction base64UrlToJson(b64url) {\n  const s = b64url.replace(/-/g, '+').replace(/_/g, '/');\n  const json = Buffer.from(s, 'base64').toString('utf8');\n  return JSON.parse(json);\n}\nfunction decodeJwt(token) {\n  const [, payload] = String(token || '').split('.');\n  if (!payload) {return null;}\n  try {\n    return base64UrlToJson(payload);\n  } catch {\n    return null;\n  }\n}\nfunction epochSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\n\n/** Login email/password -> enregistre session (refreshToken + idToken + exp) */\nexport async function login(email, password) {\n  const url = `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${API_KEY}`;\n  const r = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ email, password, returnSecureToken: true }),\n  });\n  const body = await r.json();\n  if (!r.ok) {return { ok: false, status: r.status, error: body?.error?.message || 'LOGIN_FAILED' };}\n\n  const { idToken, refreshToken, localId } = body;\n  const payload = decodeJwt(idToken) || {};\n  const exp = Number(payload?.exp || 0);\n  writeSession({ email, localId, refreshToken, idToken, idTokenExp: exp });\n  return { ok: true, localId, email, idTokenExp: exp };\n}\n\n/** Rafraîchir via refresh_token (securetoken) et mettre à jour la session */\nasync function refreshWithToken(refreshToken) {\n  const url = `https://securetoken.googleapis.com/v1/token?key=${API_KEY}`;\n  const form = new URLSearchParams();\n  form.append('grant_type', 'refresh_token');\n  form.append('refresh_token', refreshToken);\n\n  const r = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: form.toString(),\n  });\n  const body = await r.json();\n  if (!r.ok) {throw new Error(body?.error?.message || 'REFRESH_FAILED');}\n\n  const newId = body?.id_token;\n  const newRefresh = body?.refresh_token || refreshToken;\n  const payload = decodeJwt(newId) || {};\n  const exp = Number(payload?.exp || 0);\n\n  const sess = readSession() || {};\n  const updated = { ...sess, idToken: newId, idTokenExp: exp, refreshToken: newRefresh };\n  writeSession(updated);\n  return newId;\n}\n\n/** Retourne un idToken valide (refresh si expiré ou < 60s d’expiration) */\nexport async function getValidIdToken() {\n  const sess = readSession();\n  if (!sess?.refreshToken) {throw new Error('NO_SESSION');}\n  const now = epochSeconds();\n  const exp = Number(sess?.idTokenExp || 0);\n  const margin = 60; // secondes\n  if (sess?.idToken && exp > now + margin) {return sess.idToken;}\n  return await refreshWithToken(sess.refreshToken);\n}\n\n/** Infos basiques depuis le token */\nexport async function whoami() {\n  const token = await getValidIdToken();\n  const p = decodeJwt(token) || {};\n  return {\n    uid: p?.user_id || p?.sub || null,\n    email: p?.email || null,\n    exp: p?.exp || null,\n    iat: p?.iat || null,\n  };\n}\n\n/** Appel d’une API protégée (exemple) */\nexport async function callProtected(url, method = 'GET', body = null) {\n  const token = await getValidIdToken();\n  const r = await fetch(url, {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${token}`,\n    },\n    body: body ? JSON.stringify(body) : null,\n  });\n  return { status: r.status, body: await r.text() };\n}\n\n/** Déconnexion: supprime la session locale */\nexport async function logout() {\n  deleteSession();\n  return { ok: true };\n}\n\n/** Supprimer définitivement le compte (⚠️ irréversible) */\nexport async function deleteAccount() {\n  const idToken = await getValidIdToken();\n  const url = `https://identitytoolkit.googleapis.com/v1/accounts:delete?key=${API_KEY}`;\n  const r = await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ idToken }),\n  });\n  const body = await r.json();\n  if (!r.ok) {return { ok: false, status: r.status, error: body?.error?.message || 'DELETE_FAILED' };}\n  deleteSession();\n  return { ok: true };\n}\n\n/** Utilitaire: voir la session brute (pour debug local) */\nexport function readSessionFile() {\n  return readSession();\n}\n"
    }
  ]
}
