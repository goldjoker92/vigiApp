{
  "sourceFile": "functions_api/passwordService.js",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1758952621493,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1758952621493,
      "name": "Commit-0",
      "content": "import { randomBytes, scrypt as _scrypt, timingSafeEqual } from 'crypto';\nimport { promisify } from 'node:util';\nimport { HASH_SCHEMES } from './securityConfig.js';\nimport * as functions from 'firebase-functions';\nconst { Buffer } = require('buffer');\n\nconst scrypt = promisify(_scrypt);\n\n// Récupère le pepper via functions.config() (déjà présent chez toi)\nfunction getPepperFromConfig() {\n  return functions.config()?.security?.pepper_v1;\n}\n\nfunction getPepper(saltId) {\n  const key = HASH_SCHEMES[saltId]?.pepperParamKey;\n  if (key !== 'security.pepper_v1') {throw new Error('Unknown saltId or pepper key');}\n  const val = getPepperFromConfig();\n  if (!val)\n    {throw new Error('Missing pepper (firebase functions:config:set security.pepper_v1=\"...\")');}\n  return val;\n}\n\n// Hash pour stockage: scrypt(toHash, perUserSalt, 64) -> hex\nexport async function hashForStorageFromClientPrehash(clientPrehash, saltId) {\n  const pepper = getPepper(saltId);\n  const perUserSalt = randomBytes(16).toString('hex');\n  const toHash = `${clientPrehash}:${pepper}:${perUserSalt}`;\n  const key = await scrypt(toHash, Buffer.from(perUserSalt, 'hex'), 64);\n  const storedHash = Buffer.from(key).toString('hex');\n  return { storedHash, perUserSalt, hashVersion: saltId };\n}\n\nexport async function verifyFromClientPrehash(clientPrehash, user) {\n  const pepper = getPepper(user.hashVersion);\n  const toVerify = `${clientPrehash}:${pepper}:${user.perUserSalt}`;\n  const key = await scrypt(toVerify, Buffer.from(user.perUserSalt, 'hex'), 64);\n  const calc = Buffer.from(key);\n  const stored = Buffer.from(user.storedHash, 'hex');\n  if (stored.length !== calc.length) {return false;}\n  return timingSafeEqual(stored, calc);\n}\n"
    }
  ]
}
